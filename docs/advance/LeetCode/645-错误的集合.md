---
title: 645. 错误的集合
tag:
  - 数组
  - 哈希表
date: 2022-12-13
---

## 题目链接

- [645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/)

## 题目描述 <Badge text="简单" type="tip"/>

合 `s` 包含从 `1` 到 `n` 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 **有一个数字重复** 。

给定一个数组 `nums` 代表了集合 `S` 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

**示例 1：**

```
输入：nums = [1,2,2,4]
输出：[2,3]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[1,2]
```

## 解题思路

1. 将数组从小到大排序

2. 寻找重复的数字较为简单，如果相邻的两个元素相等，则该元素为重复的数字。

3. 寻找丢失的数字相对复杂，可能有以下两种情况：

   - 如果丢失的数字大于 1 且小于 n，则一定存在相邻的两个元素的差等于 2，这两个元素之间的值即为丢失的数字；

   - 如果丢失的数字是 1 或 n，则需要另外判断。

4. 为了寻找丢失的数字，需要在遍历已排序数组的同时记录上一个元素，然后计算当前元素与上一个元素的差。考虑到丢失的数字可能是 1，因此需要将上一个元素初始化为 0。

   - 当丢失的数字小于 n 时，通过计算当前元素与上一个元素的差，即可得到丢失的数字；

   - 如果数组最后一个数，不等于 n，则丢失的为 n。

## 示例代码

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int[] errorNums = new int[2];
        Arrays.sort(nums);
        // 记录前一个元素的值，虑到丢失的数字可能是 1，因此需要将上一个元素初始化为 0，这样如果丢失的是 1，则 2-0 > 1 可以找到丢失的数是 1
        int prev = 0;
        for(int i=0;i<n;i++) {
            if(nums[i] == prev) {
                errorNums[0] = prev;
            } else if(nums[i] - prev > 1) {
                errorNums[1] = prev + 1;
            }
            prev = nums[i];
        }
        // 判断丢失的是不是最后一位 n
        if(nums[n - 1] != n) {
            errorNums[1] = n;
        }
        return errorNums;
    }
}
```

## 复杂度分析

- 时间复杂度：O(nlog⁡n)，其中 n 是数组 nums 的长度。排序需要 O(nlog⁡n) 的时间，遍历数组找到错误的集合需要 O(n) 的时间，因此总时间复杂度是 O(nlog⁡n)。

- 空间复杂度：O(log⁡n)，其中 n 是数组 nums 的长度。排序需要 O(log⁡n) 的空间。









