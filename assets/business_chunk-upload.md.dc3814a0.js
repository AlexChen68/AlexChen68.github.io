import{_ as e,o as a,c as l,Q as i}from"./chunks/framework.01af844e.js";const b=JSON.parse('{"title":"文件分片上传和断点续传","description":"","frontmatter":{"title":"文件分片上传和断点续传","date":"2024-10-31T00:00:00.000Z","order":2},"headers":[],"relativePath":"business/chunk-upload.md","filePath":"business/chunk-upload.md","lastUpdated":1730355395000}'),o={name:"business/chunk-upload.md"},t=i('<h1 id="文件分片上传和断点续传" tabindex="-1">文件分片上传和断点续传 <a class="header-anchor" href="#文件分片上传和断点续传" aria-label="Permalink to &quot;文件分片上传和断点续传&quot;">​</a></h1><blockquote><p>本文使用 MinIO 作为文件服务中间件，前端使用 vue3 和 ElementPlus，后端使用 springboot 实现文件上传中的分片、断点续传功能。</p></blockquote><h2 id="实现思路" tabindex="-1">实现思路： <a class="header-anchor" href="#实现思路" aria-label="Permalink to &quot;实现思路：&quot;">​</a></h2><ol><li>前端对大文件计算 MD5 值，然后对文件进行分片，计算分片数量；</li><li>前端携带 MD5 值请求服务端，查询文件是否已经上传过以及是否上传完毕： <ol><li>如果未上传，返回为空；则前端调用初始化接口初始化一个任务；</li><li>如果已上传完毕，则直接返回文件相关信息；</li><li>如果已上传但是未上传完毕，则返回文件信息及已上传分片信息；</li></ol></li><li>前端根据服务端返回的文件信息，判断是否需要上传分片，如果分片未上传，则上传分片，如果分片已上传，则跳过分片上传（即断点续传）：</li><li>文件上传有两种方式： <ol><li>前端请求服务端获取每个分片的上传地址（如 MinIO 服务的上传地址），然后直接请求该地址将文件上传至 MinIO，无需经过服务端，节省带宽但是安全性低；</li><li>前端将分片上传到服务端，由服务端将分片上传至 MinIO，需要占用服务端带宽，但是安全性高；</li></ol></li><li>前端将全部分片上传完毕后，请求服务端端合并分片接口；服务端调用文件服务中间件进行合并分片，然后返回文件相关信息。</li></ol><h2 id="前后端代码参考" tabindex="-1">前后端代码参考 <a class="header-anchor" href="#前后端代码参考" aria-label="Permalink to &quot;前后端代码参考&quot;">​</a></h2><p>参考仓库：<a href="https://github.com/KKJava1/Upload-Springboot-Minio-liveplayer" target="_blank" rel="noreferrer">Upload-Springboot-Minio-liveplayer</a></p>',6),r=[t];function n(s,c,d,h,p,_){return a(),l("div",null,r)}const m=e(o,[["render",n]]);export{b as __pageData,m as default};
