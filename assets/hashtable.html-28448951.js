import{_ as n,W as a,X as s,Y as e,a0 as o,Z as r,a1 as l,C as p}from"./framework-d3200c61.js";const c={},h=l('<h2 id="哈希表概述" tabindex="-1"><a class="header-anchor" href="#哈希表概述" aria-hidden="true">#</a> 哈希表概述</h2><p>哈希表（英文名字为 Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指 hash table 就可以了）。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p><strong>哈希表能解决什么问题</strong>：</p><ol><li>快速判断一个元素是否出现集合里；</li><li>实现缓存。</li></ol><p><strong>哈希表的原理：</strong></p><blockquote><p>通过将<strong>散列函数</strong>将<strong>输入</strong>映射为<strong>数字</strong>，对应<strong>数组</strong>的索引下标，将数据存储在对应索引的位置中；</p><p>散列函数将不同的输入映射到不同的索引，从而可以利用<strong>数组</strong>实现时间复杂度为 <strong>O(1)</strong> 的快速查询。</p></blockquote><p>从哈希表的原理可以看出，<strong>散列函数</strong>的选择对整个哈希表的性能有较大的影响，越好的散列函数越能均匀地映射到散列表的不同位置；</p><p>另外，散列函数并不能完全将不同的输入映射到不同的索引，这种情况叫做<strong>散列冲突</strong>（哈希碰撞）。</p><p><strong>如何解决散列冲突</strong></p><p>一般哈希碰撞有两种解决方法，拉链法和线性探测法。</p><p>拉链法：因为多个输入散列后可能得到同一个索引，那么我们可以在数组存储一个链表或者别的数据结构，用来存储散列结果一致的输入。</p><p>在 Java 的 HashMap 中，就是使用了<strong>链表</strong>和<strong>红黑树</strong>，来解决散列冲突的。</p><p>线性探测法：如果发生冲突，那就向下寻找一个空位存放冲突的数据。</p><h2 id="常见的哈希表表示" tabindex="-1"><a class="header-anchor" href="#常见的哈希表表示" aria-hidden="true">#</a> 常见的哈希表表示</h2><ol><li>数组</li><li>Set 集合</li><li>Map 映射</li></ol><h2 id="相关算法题" tabindex="-1"><a class="header-anchor" href="#相关算法题" aria-hidden="true">#</a> 相关算法题</h2>',17),i={href:"https://leetcode.cn/problems/two-sum/",target:"_blank",rel:"noopener noreferrer"},d={href:"https://leetcode.cn/problems/valid-anagram/",target:"_blank",rel:"noopener noreferrer"};function g(_,u){const t=p("ExternalLinkIcon");return a(),s("div",null,[h,e("ul",null,[e("li",null,[e("a",i,[o("001. 两数之和"),r(t)])]),e("li",null,[e("a",d,[o("242. 有效的字母异位词"),r(t)])])])])}const f=n(c,[["render",g],["__file","hashtable.html.vue"]]);export{f as default};
