const e=JSON.parse(`{"key":"v-148d317f","path":"/advance/algo/sort/3.1-selection.html","title":"3.1 选择排序","lang":"zh-CN","frontmatter":{"title":"3.1 选择排序","category":"算法","tag":["排序算法"],"date":"2023-04-03T00:00:00.000Z","description":"简介 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。 唯一的好处可能就是不占用额外的内存空间了吧。 选择排序步骤 首先在未排序的数列中找到最小 (or 最大) 元素，然后将其存放到数列的起始位置； 接着，再从剩余未排序的元素中继续寻找最小 (or 最大) 元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。","head":[["meta",{"property":"og:url","content":"https://github.com/AlexChen68/AlexChen68.github.io/advance/algo/sort/3.1-selection.html"}],["meta",{"property":"og:site_name","content":"AlexChen's Blog"}],["meta",{"property":"og:title","content":"3.1 选择排序"}],["meta",{"property":"og:description","content":"简介 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。 唯一的好处可能就是不占用额外的内存空间了吧。 选择排序步骤 首先在未排序的数列中找到最小 (or 最大) 元素，然后将其存放到数列的起始位置； 接着，再从剩余未排序的元素中继续寻找最小 (or 最大) 元素，然后放到已排序序列的末尾。 以此类推，直到所有元素均排序完毕。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-02T19:58:12.000Z"}],["meta",{"property":"article:author","content":"AlexChen"}],["meta",{"property":"article:tag","content":"排序算法"}],["meta",{"property":"article:published_time","content":"2023-04-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-02T19:58:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"3.1 选择排序\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-04-03T00:00:00.000Z\\",\\"dateModified\\":\\"2023-06-02T19:58:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"AlexChen\\",\\"url\\":\\"https://github.com/AlexChen68\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"选择排序步骤","slug":"选择排序步骤","link":"#选择排序步骤","children":[]},{"level":2,"title":"演示动画","slug":"演示动画","link":"#演示动画","children":[]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]},{"level":2,"title":"复杂度分析","slug":"复杂度分析","link":"#复杂度分析","children":[]}],"git":{"createdTime":1680719082000,"updatedTime":1685735892000,"contributors":[{"name":"alexchen","email":"1274812218@qq.com","commits":2}]},"readingTime":{"minutes":1.04,"words":311},"filePathRelative":"advance/algo/sort/3.1-selection.md","localizedDate":"2023年4月3日","excerpt":"<h2> 简介</h2>\\n<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 <em>O(n<sup>²</sup>)</em> 的时间复杂度。所以用到它的时候，<strong>数据规模越小越好</strong>。</p>\\n<p>唯一的好处可能就是不占用额外的内存空间了吧。</p>\\n<h2> 选择排序步骤</h2>\\n<ol>\\n<li>首先在未排序的数列中找到最小 (or 最大) 元素，然后将其存放到数列的起始位置；</li>\\n<li>接着，再从剩余未排序的元素中继续寻找最小 (or 最大) 元素，然后放到已排序序列的末尾。</li>\\n<li>以此类推，直到所有元素均排序完毕。</li>\\n</ol>","autoDesc":true}`);export{e as data};
