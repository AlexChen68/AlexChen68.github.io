const e=JSON.parse(`{"key":"v-9b9fff56","path":"/advance/algo/sort/4-merge.html","title":"4. 归并排序","lang":"zh-CN","frontmatter":{"title":"4. 归并排序","category":"算法","tag":["排序算法"],"date":"2023-04-03T00:00:00.000Z","description":"简介 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代； 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。","head":[["meta",{"property":"og:url","content":"https://github.com/AlexChen68/AlexChen68.github.io/advance/algo/sort/4-merge.html"}],["meta",{"property":"og:site_name","content":"AlexChen's Blog"}],["meta",{"property":"og:title","content":"4. 归并排序"}],["meta",{"property":"og:description","content":"简介 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代； 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-11T06:27:13.000Z"}],["meta",{"property":"article:tag","content":"排序算法"}],["meta",{"property":"article:published_time","content":"2023-04-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-11T06:27:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4. 归并排序\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-04-03T00:00:00.000Z\\",\\"dateModified\\":\\"2023-04-11T06:27:13.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"排序步骤","slug":"排序步骤","link":"#排序步骤","children":[]},{"level":2,"title":"演示动画","slug":"演示动画","link":"#演示动画","children":[]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]},{"level":2,"title":"复杂度分析","slug":"复杂度分析","link":"#复杂度分析","children":[]}],"git":{"createdTime":1680719082000,"updatedTime":1681194433000,"contributors":[{"name":"alexchen","email":"1274812218@qq.com","commits":2}]},"readingTime":{"minutes":2.81,"words":843},"filePathRelative":"advance/algo/sort/4-merge.md","localizedDate":"2023年4月3日","excerpt":"<h2> 简介</h2>\\n<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>\\n<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>\\n<ul>\\n<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>\\n<li>自下而上的迭代；</li>\\n</ul>\\n<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 <em>O(nlogn)</em> 的时间复杂度。代价是需要额外的内存空间。</p>","autoDesc":true}`);export{e as data};
