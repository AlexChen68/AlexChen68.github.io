import{_ as a,o as l,c as e,Q as t}from"./chunks/framework.01af844e.js";const b=JSON.parse('{"title":"Mysql 同步 ES 大宽表","description":"","frontmatter":{"title":"Mysql 同步 ES 大宽表","date":"2023-10-27T00:00:00.000Z","order":102},"headers":[],"relativePath":"database/mysql/mysql-to-es.md","filePath":"database/mysql/mysql-to-es.md","lastUpdated":1707632099000}'),o={name:"database/mysql/mysql-to-es.md"},i=t('<h1 id="mysql-同步-elasticsearch-大宽表实践" tabindex="-1">Mysql 同步 ElasticSearch 大宽表实践 <a class="header-anchor" href="#mysql-同步-elasticsearch-大宽表实践" aria-label="Permalink to &quot;Mysql 同步 ElasticSearch 大宽表实践&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>数据同步大宽表：把多张 Mysql 中的业务数据表组合成一张大宽表，一般业内选择使用 ES 来存储大宽表。</p><h2 id="为什么要用-es-构建大宽表" tabindex="-1">为什么要用 ES 构建大宽表 <a class="header-anchor" href="#为什么要用-es-构建大宽表" aria-label="Permalink to &quot;为什么要用 ES 构建大宽表&quot;">​</a></h2><ol><li>Mysql 多表 join 性能很差</li><li>Mysql 无法应对复杂条件查询</li><li>Mysql 模糊查询和全文查询能力弱</li><li>ES 是全文搜索引擎，有丰富的分词插件，支持自定义打分和排序，甚至可以引入检索算法实现语义理解</li></ol><p>因此，可以将多个表的 Mysql 数据，同步到 ES 一张大宽表中，实现全局搜索；这需要一个同步方案。</p><h2 id="如何从-mysql-同步数据到-es" tabindex="-1">如何从 Mysql 同步数据到 ES <a class="header-anchor" href="#如何从-mysql-同步数据到-es" aria-label="Permalink to &quot;如何从 Mysql 同步数据到 ES&quot;">​</a></h2><p>目前主要有四种方案：同步双写、异步双写、定时任务调度、binlog 同步</p><h3 id="同步双写" tabindex="-1">同步双写 <a class="header-anchor" href="#同步双写" aria-label="Permalink to &quot;同步双写&quot;">​</a></h3><blockquote><p>这是一种最为简单的方式，在将数据写到 mysql 时，同时将数据写到 ES。</p></blockquote><h3 id="异步双写" tabindex="-1">异步双写 <a class="header-anchor" href="#异步双写" aria-label="Permalink to &quot;异步双写&quot;">​</a></h3><blockquote><p>由于发消息比写 es 快多了，所以异步双写通过发消息来异步执行写 es 的逻辑！</p></blockquote><h3 id="定时任务调度" tabindex="-1">定时任务调度 <a class="header-anchor" href="#定时任务调度" aria-label="Permalink to &quot;定时任务调度&quot;">​</a></h3><blockquote><p>上面两种方案中都存在硬编码问题，也就是有任何对 mysq 进行增删改查的地方要么植入 ES 代码，要么替换为 MQ 代码，代码的侵入性太强，若是实时要求不高的情况下，可以考虑用&gt; 定时器来处理，具体步骤如下：</p><ol><li>数据库的相关表中增加一个字段为 timestamp 的字段，任何 crud 操作都会导致该字段的时间发生变化；</li><li>原来程序中的 crud 操作不做任何变化；</li><li>增加一个定时器程序，让该程序按一定的时间周期扫描指定的表，把该时间段内发生变化的数据提取出来；</li><li>逐条写入到 ES 中。</li></ol></blockquote><h2 id="binlog-同步" tabindex="-1">Binlog 同步 <a class="header-anchor" href="#binlog-同步" aria-label="Permalink to &quot;Binlog 同步&quot;">​</a></h2><blockquote><p>上面三种方案要不有代码侵入、要不有硬编码、要不有时延，那么有没有一种稍微折中的方法嘞？答案就是利用 mysql 的 binlog！ 具体步骤如下：</p><ul><li>读取 mysql 的 binlog 日志，获取指定表的日志信息；</li><li>将读取的信息转为 MQ；</li><li>编写一个 MQ 消费程序；</li><li>不断消费 MQ，每消费完一条消息，将消息写入到 ES 中。</li></ul></blockquote><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/626136604" target="_blank" rel="noreferrer">MySQL 同步 ElasticSearch 大宽表实践</a></li></ul>',18),s=[i];function r(h,c,n,q,d,u){return l(),e("div",null,s)}const p=a(o,[["render",r]]);export{b as __pageData,p as default};
