import{_ as t,W as o,X as s,a1 as r}from"./framework-7c4b0f0a.js";const n={},e=r('<h2 id="哈希表概述" tabindex="-1"><a class="header-anchor" href="#哈希表概述" aria-hidden="true">#</a> 哈希表概述</h2><p>哈希表（英文名字为 Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指 hash table 就可以了）。</p><blockquote><p>哈希表是根据关键码的值而直接进行访问的数据结构。</p></blockquote><p><strong>哈希表能解决什么问题</strong>：</p><ol><li>快速判断一个元素是否出现集合里；</li><li>实现缓存。</li></ol><p><strong>哈希表的原理：</strong></p><blockquote><p>通过将<strong>散列函数</strong>将<strong>输入</strong>映射为<strong>数字</strong>，对应<strong>数组</strong>的索引下标，将数据存储在对应索引的位置中；</p><p>散列函数将不同的输入映射到不同的索引，从而可以利用<strong>数组</strong>实现时间复杂度为 <strong>O(1)</strong> 的快速查询。</p></blockquote><p>从哈希表的原理可以看出，<strong>散列函数</strong>的选择对整个哈希表的性能有较大的影响，越好的散列函数越能均匀地映射到散列表的不同位置；</p><p>另外，散列函数并不能完全将不同的输入映射到不同的索引，这种情况叫做<strong>散列冲突</strong>（哈希碰撞）。</p><p><strong>如何解决散列冲突</strong></p><p>因为多个输入散列后可能得到同一个索引，那么我们可以在数组存储一个链表或者别的数据结构，用来存储散列结果一致的输入。</p><p>在 Java 的 HashMap 中，就是使用了<strong>链表</strong>和<strong>红黑树</strong>，来解决散列冲突的。</p><h2 id="相关算法题" tabindex="-1"><a class="header-anchor" href="#相关算法题" aria-hidden="true">#</a> 相关算法题</h2>',13),a=[e];function p(g,h){return o(),s("div",null,a)}const c=t(n,[["render",p],["__file","hashtable.html.vue"]]);export{c as default};
