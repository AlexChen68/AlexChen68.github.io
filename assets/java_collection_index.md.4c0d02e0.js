import{_ as a,o as e,c as o,Q as l}from"./chunks/framework.419948d5.js";const m=JSON.parse('{"title":"Java 集合框架 - 概览","description":"","frontmatter":{"title":"Java 集合框架 - 概览","date":"2022-09-30T00:00:00.000Z"},"headers":[],"relativePath":"java/collection/index.md","filePath":"java/collection/index.md","lastUpdated":1697497069000}'),t={name:"java/collection/index.md"},s=l('<p>本文介绍 Java 集合框架的各类接口和常用子类。</p><h2 id="java-集合框架" tabindex="-1">Java 集合框架 <a class="header-anchor" href="#java-集合框架" aria-label="Permalink to &quot;Java 集合框架&quot;">​</a></h2><p>容器，就是可以容纳其他 Java 对象的对象。<em>Java Collections Framework(JCF)</em> 为 Java 开发者提供了通用的容器，其始于 JDK 1.2，优点是：</p><ul><li><p>降低编程难度</p></li><li><p>提高程序性能</p></li><li><p>提高 API 间的互操作性</p></li><li><p>降低学习难度</p></li><li><p>降低设计和实现相关 API 的难度</p></li><li><p>增加程序的重用性</p></li></ul><p>Java 容器里只能放对象，对于基本类型 (int, long, float, double 等)，需要将其包装成对象类型后 (Integer, Long, Float, Double 等) 才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</p><p>Java 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对 (两个对象) 的映射表：</p><ol><li>Collection：主要由 List、Set、Queue 组成。 <ul><li>List 代表有序、可重复的集合，典型代表就是封装了动态数组的 ArrayList 和封装了链表的 LinkedList；</li><li>Set 代表无序、不可重复的集合，典型代表就是 HashSet 和 TreeSet；</li><li>Queue 代表队列，典型代表就是双端队列 ArrayDeque，以及优先级队列 PriorityQue。</li></ul></li><li>Map：代表键值对的集合，典型代表就是 HashMap。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/AlexChen68/OSS@master/blog/java/collection_framework.png" alt="Java 集合框架" title=":size=80%"></p><h2 id="collection-接口" tabindex="-1"><code>Collection</code> 接口 <a class="header-anchor" href="#collection-接口" aria-label="Permalink to &quot;`Collection` 接口&quot;">​</a></h2><p><code>Collection</code> 是所有序列集合共有的根接口。集合表示一组对象，称为其元素。一些集合允许重复元素，而另一些则不允许。有些是有序的，有些是无序的。JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List）的实现。此接口通常用于传递集合并在需要最大通用性的地方操作它们。</p><p><code>Collection</code>接口继承了 <code>Iterable</code>接口，实现 <code>Collection</code> 就意味着需要提供 <code>iterator()</code> 方法</p><p><code>java.util.AbstractCollection</code> 类提供了 <code>Collection</code> 类的默认实现，使得你可以创建 <code>AbstractCollection</code> 的子类型，而其中没有不必要的代码重复。</p><p>Java 访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p><h3 id="list-接口" tabindex="-1"><code>List</code> 接口 <a class="header-anchor" href="#list-接口" aria-label="Permalink to &quot;`List` 接口&quot;">​</a></h3><p><code>java.util.List</code> 接口继承自 <code>Collection</code> 接口，是单列集合的一个重要分支，习惯性地会将实现了 List 接口的对象称为 List 集合。</p><p>在 List 集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。</p><p>另外，List 集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p><ol><li><code>ArrayList</code></li></ol><p><code>ArrayList</code> 底层是由数组实现的，支持随机存取，也就是可以通过下标直接存取元素；</p><p>如果内部数组的容量不足时会自动扩容，因此当元素非常庞大的时候，效率会比较低。</p><p>所以 ArrayList 的特点是元素增删慢，查找快。</p><ol start="2"><li><code>LinkedList</code></li></ol><p><code>LinkedList</code> 是由双向链表实现的，不支持随机存取，只能从一端开始遍历，直到找到需要的元素后返回；</p><p>任意位置插入和删除元素都很方便，因为只需要改变前一个节点和后一个节点的引用即可，不像 ArrayList 那样需要复制和移动数组元素；</p><p>因为每个元素都存储了前一个和后一个节点的引用，所以相对来说，占用的内存空间会比 ArrayList 多一些。</p><ol start="3"><li><code>Vector</code></li></ol><p>和 ArrayList 类似，但它是线程安全的，一些方法都加了 <code>synchronized</code>关键字，执行效率会比较低，很少使用。</p><ol start="4"><li><code>Stack</code></li></ol><p><code>Stack</code> 继承了 <code>Vector</code>，在其基础上实现了栈先进先出的功能（push、pop、peek 等方法），方法上同样添加了 <code>synchronized</code> 关键字，官方推荐使用双端队列 <code>ArrayDeque</code>。</p><h3 id="queue-接口" tabindex="-1">Queue 接口 <a class="header-anchor" href="#queue-接口" aria-label="Permalink to &quot;Queue 接口&quot;">​</a></h3><p>Queue 接口继承了 <code>Collection</code>，被设计用于处理之前临时保存在某处的元素。</p><p>除了基本的 <code>Collection</code> 操作之外，队列还提供了额外的插入、提取和检查操作。每一种操作都有两种形式：如果操作失败，则抛出一个异常；如果操作失败，则返回一个特殊值（null 或 false，取决于是什么操作）。</p><ol><li><code>ArrayDeque</code></li></ol><p><code>ArrayDeque</code> 是一个基于数组实现的双端队列，它使用一个头指针 <code>head</code> 指向队首的第一个有效的元素和一个尾指针 <code>tail </code>指向队尾第一个可以插入元素的空位构成一个循环数组。</p><ol start="2"><li><code>LinkedList</code></li></ol><p>LinkedList 也实现了 Deque 接口，由于其内部双向链表的特性，也可以作为链表实现的双向队列使用。</p><ol start="3"><li><code>PriorityQueue</code></li></ol><p><code>PriorityQueue</code> 是一种优先级队列，它的出队顺序与元素的优先级有关，执行 remove 或者 poll 方法，返回的总是优先级最高的元素。</p><p>要想有优先级，元素就需要实现 <code>Comparable</code> 接口或者 <code>Comparator</code> 接口</p><h3 id="set-接口" tabindex="-1">Set 接口 <a class="header-anchor" href="#set-接口" aria-label="Permalink to &quot;Set 接口&quot;">​</a></h3><p>Set 的特点是存取无序，不可以存放重复的元素，不可以用下标对元素进行操作，和 List 有很多不同。</p><p>Set 的子类大多使用 Map 的子类的 key 存储数据，利用了 Map 键不允许重复、无序的特性。</p><ol><li><code>HashSet</code></li></ol><p>HashSet 内部是由 HashMap 实现的，只不过值由一个固定的 Object 对象填充，而键用于操作。</p><ol start="2"><li><code>LinkedHashSet</code></li></ol><p>LinkedHashSet 继承自 HashSet，其实是由 LinkedHashMap 实现的，LinkedHashSet 的构造方法调用了 HashSet 的一个特殊的构造方法：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">HashSet</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> initialCapacity, </span><span style="color:#F97583;">float</span><span style="color:#E1E4E8;"> loadFactor, </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> dummy) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">   map </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">HashSet</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> initialCapacity, </span><span style="color:#D73A49;">float</span><span style="color:#24292E;"> loadFactor, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> dummy) {</span></span>\n<span class="line"><span style="color:#24292E;">   map </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span></span>\n<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="3"><li><code>TreeSet</code></li></ol><p>TreeSet 内部使用 TreeMap 实现，同样值由固定的 Object 对象填充，键用于操作。</p><h2 id="map-接口" tabindex="-1">Map 接口 <a class="header-anchor" href="#map-接口" aria-label="Permalink to &quot;Map 接口&quot;">​</a></h2><blockquote><p>Map 保存的是键值对，键要求保持唯一性，值可以重复。</p></blockquote><ol><li><code>HashMap</code></li></ol><p>HashMap 实现了 Map 接口，根据键的 <strong>HashCode</strong> 值来存储数据，具有很快的访问速度，最多允许一个 null 键。</p><p>HashMap 不论是在学习还是工作当中，使用频率都是相当高的。随着 JDK 版本的不断更新，HashMap 的底层也优化了很多次，JDK 8 的时候引入了<strong>红黑树</strong>。</p><p>一旦 HashMap 发生哈希冲突，就把相同键位的地方改成链表，如果链表的长度超过 8，就该用红黑树。</p><ol start="2"><li><code>LinkedHashMap</code></li></ol><p>LinkedHashMap 是 HashMap 的子类，内部使用链表来记录插入/访问元素的顺序。</p><p>LinkedHashMap 可以看作是 HashMap + LinkedList 的合体，它使用了 哈希表来存储数据，又用了双向链表来维持顺序。</p><ol start="3"><li><code>TreeMap</code></li></ol><p>HashMap 是无序的，所以遍历的时候元素的顺序也是不可测的。TreeMap 是有序的，它在内部会对键进行排序，所以遍历的时候就可以得到预期的顺序。</p><p>为了保证顺序，TreeMap 的键必须要实现 Comparable 接口或者 Comparator 接口。</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://tobebetterjavaer.com/collection/gailan.html" target="_blank" rel="noreferrer">Java 程序员进阶之路</a></li><li><a href="https://pdai.tech/md/java/collection/java-collection-all.html" target="_blank" rel="noreferrer">Java 全栈知识体系</a></li></ul>',63),p=[s];function i(c,n,r,d,h,u){return e(),o("div",null,p)}const b=a(t,[["render",i]]);export{m as __pageData,b as default};
