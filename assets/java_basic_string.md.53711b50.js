import{_ as t,C as o,o as l,c as e,k as s,H as p,Q as n}from"./chunks/framework.01af844e.js";const q=JSON.parse('{"title":"Java String 详解","description":"","frontmatter":{"title":"Java String 详解","order":2,"date":"2022-09-15T00:00:00.000Z"},"headers":[],"relativePath":"java/basic/string.md","filePath":"java/basic/string.md","lastUpdated":1700320668000}'),r={name:"java/basic/string.md"},c=n('<h1 id="java-string-详解" tabindex="-1">Java String 详解 <a class="header-anchor" href="#java-string-详解" aria-label="Permalink to &quot;Java String 详解&quot;">​</a></h1><h2 id="string-概述" tabindex="-1">String 概述 <a class="header-anchor" href="#string-概述" aria-label="Permalink to &quot;String 概述&quot;">​</a></h2><p>String 内部使用<strong>字符数组</strong>实现，且 String 被声明为 <code>final</code>，不可以被继承，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><p>当我们调用 String 类的任何方法（比如说 <code>trim()</code>、<code>substring()</code>、<code>toLowerCase()</code>）时，总会返回一个新的对象，而不影响之前的值。</p><p>Java 9 以前，String 是用 char 型数组实现的，之后改成了 byte 型数组实现，并增加了 <code>coder</code> 来表示编码。</p>',5),i={class:"tip custom-block"},E=s("p",{class:"custom-block-title"},"TIP",-1),y=s("strong",null,"String 不可变的优点",-1),d=n('<ol><li><strong>可以缓存 hash 值</strong></li></ol><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><ol start="2"><li><strong>String Pool 的需要</strong></li></ol><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><ol start="3"><li><strong>安全性</strong></li></ol><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><ol start="4"><li><strong>线程安全</strong></li></ol><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>',8),g=n(`<h2 id="string-家族对比" tabindex="-1">String 家族对比 <a class="header-anchor" href="#string-家族对比" aria-label="Permalink to &quot;String 家族对比&quot;">​</a></h2><table><thead><tr><th>类型</th><th>可变</th><th>线程安全</th></tr></thead><tbody><tr><td>String</td><td>不可变</td><td>安全</td></tr><tr><td>StringBuilder</td><td>可变</td><td>不安全</td></tr><tr><td>StringBuffer</td><td>可变</td><td>安全，使用 synchronized 同步</td></tr></tbody></table><h2 id="string-intern" tabindex="-1"><code>String.intern()</code> <a class="header-anchor" href="#string-intern" aria-label="Permalink to &quot;\`String.intern()\`&quot;">​</a></h2><p>使用 String.intern() 可以保证<strong>相同内容的字符串变量引用同一的内存对象</strong>。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池) 中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">String s1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">String</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;aaa&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">String s2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">String</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;aaa&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(s1 </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> s2);           </span><span style="color:#6A737D;">// false</span></span>
<span class="line"><span style="color:#E1E4E8;">String s3 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s1.</span><span style="color:#B392F0;">intern</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(s1.</span><span style="color:#B392F0;">intern</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> s3);  </span><span style="color:#6A737D;">// true</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">String s1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;aaa&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">String s2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;aaa&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(s1 </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> s2);           </span><span style="color:#6A737D;">// false</span></span>
<span class="line"><span style="color:#24292E;">String s3 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s1.</span><span style="color:#6F42C1;">intern</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(s1.</span><span style="color:#6F42C1;">intern</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> s3);  </span><span style="color:#6A737D;">// true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果是采用 &quot;bbb&quot; 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 <strong>String Pool</strong> 中。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">String s4 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;bbb&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">String s5 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;bbb&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(s4 </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> s5);  </span><span style="color:#6A737D;">// true</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">String s4 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;bbb&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">String s5 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;bbb&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(s4 </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> s5);  </span><span style="color:#6A737D;">// true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="string-pool-字符串常量池" tabindex="-1">String Pool 字符串常量池 <a class="header-anchor" href="#string-pool-字符串常量池" aria-label="Permalink to &quot;String Pool 字符串常量池&quot;">​</a></h2><p>运行时常量池（Runtime Constant Pool）是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池；而字符串常量池是这个过程中常量字符串的存放位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个逻辑上的概念；而堆区，永久代以及元空间是实际的存放位置。</p><p>不同的虚拟机对虚拟机的规范（比如方法区）是不一样的，只有 HotSpot 才有永久代的概念，随着 HotSpot 的发展，在 JDK 8 中，取消了永久代，<em>类型信息、字段、方法、常量</em>保存在<strong>本地内存的元空间</strong>，但<em>字符串常量池、静态变量</em>仍在<strong>堆</strong>中。</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://pdai.tech/md/java/basic/java-basic-lan-basic.html" target="_blank" rel="noreferrer">Java 基础 - 知识点</a></li></ul>`,13);function u(h,S,b,_,m,v){const a=o("Badge");return l(),e("div",null,[c,s("div",i,[E,s("p",null,[y,p(a,{text:"重要",type:"warning"})]),d]),g])}const A=t(r,[["render",u]]);export{q as __pageData,A as default};
