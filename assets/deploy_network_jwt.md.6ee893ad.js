import{_ as s,o as a,c as e,Q as n}from"./chunks/framework.419948d5.js";const b=JSON.parse('{"title":"JWT 实践","description":"","frontmatter":{"title":"JWT 实践","date":"2023-05-19T00:00:00.000Z","order":3},"headers":[],"relativePath":"deploy/network/jwt.md","filePath":"deploy/network/jwt.md","lastUpdated":1698421308000}'),l={name:"deploy/network/jwt.md"},o=n(`<h2 id="什么是-jwt" tabindex="-1">什么是 JWT？ <a class="header-anchor" href="#什么是-jwt" aria-label="Permalink to &quot;什么是 JWT？&quot;">​</a></h2><p>什么是 JWT？官方的定义是：</p><blockquote><p>JSON Web Token (JWT) 是一个开放标准 (RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p></blockquote><h2 id="jwt-的构成" tabindex="-1">JWT 的构成 <a class="header-anchor" href="#jwt-的构成" aria-label="Permalink to &quot;JWT 的构成&quot;">​</a></h2><p>JWT 由三部分组成，中间使用句点 <code>.</code> 连接，即整体结构为 <strong><code>Header.Payload.Signature</code></strong>，这三个部分都是由 base64 编码的，这么做的目的是为了保证 url 中安全的传输。这三部分包含了不同的信息：</p><ul><li>Header 头部信息，主要声明了 JWT 的签名算法等信息。</li><li>Payload 载荷信息，主要承载了各种声明并传递明文数据。</li><li>Signature 签名，拥有该部分的 JWT 被称为 JWS，也就是签了名的 JWS，用于校验数据。</li></ul><p>第一部分 header 中是由两部分信息组成，即声明类型为 jwt 和声明加密的算法（例如 HS256），所以说 header 在 base64URL 编码之前是如下的 JSON：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">&quot;alg&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;HS256&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">&quot;typ&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;jwt&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">&quot;alg&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;HS256&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">&quot;typ&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;jwt&quot;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><em>base64URL</em> 编码之后为：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>第二部分 payload 是存放想要<strong>传递的信息</strong>，用来存放实际需要传递的数据。JWT 规定了 7 个官方字段，供选用。</p><blockquote><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul></blockquote><p>此外，你可以在这部分自定义数据，例如 id、username、phone 在 <em>base64URL</em> 编码之前是如下的 JSON:</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">&quot;id&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;1024&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">&quot;username&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;alexchen&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">&quot;phone&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">18388888888</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">&quot;id&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;1024&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">&quot;username&quot;</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;alexchen&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">&quot;phone&quot;</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">18388888888</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><em>base64URL</em> 编码之后为：</p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">eyJpZCI</span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">MTAyNCwibmFtZSI</span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">ImFsZXhjaGVuIiwicGhvbmUiOiIxODM</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">ODg</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">ODg</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">OCJ</span><span style="color:#79B8FF;">9</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">eyJpZCI</span><span style="color:#005CC5;">6</span><span style="color:#24292E;">MTAyNCwibmFtZSI</span><span style="color:#005CC5;">6</span><span style="color:#24292E;">ImFsZXhjaGVuIiwicGhvbmUiOiIxODM</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">ODg</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">ODg</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">OCJ</span><span style="color:#005CC5;">9</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>第三部分 <code>Signature</code> 最是关键，它的组成原理是：</p><ol><li>将 <code>header</code> 和 <code>payload</code> 分别使用 <em>base64URL</em> 编码之后的结果组合到一起（通过 <code>.</code> 连接）；</li><li>添加一个只有服务器知道的<strong>签名字符串</strong>；</li><li>再使用 <code>header</code> 中的签名算法 <em>SHA256</em> 加密步骤 1、2。可以看成下面的公式：</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Signature = SHA256(base64encode(header) + &#39;.&#39; + base64encode(payload), &#39;SEVER_SECRET_KEY&#39;)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Signature = SHA256(base64encode(header) + &#39;.&#39; + base64encode(payload), &#39;SEVER_SECRET_KEY&#39;)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>最终得到第三部分的签名串：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">0L2DzZz682cRh9WRb9S4GkcwXVWLAv9xeJFmGtIw-D4</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">0L2DzZz682cRh9WRb9S4GkcwXVWLAv9xeJFmGtIw-D4</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>最终将上面三部分通过 <code>.</code> 合并，得到最终的 JWT 串：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MTAyNCwibmFtZSI6ImFsZXhjaGVuIiwicGhvbmUiOiIxODM4ODg4ODg4OCJ9.0L2DzZz682cRh9WRb9S4GkcwXVWLAv9xeJFmGtIw-D4</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MTAyNCwibmFtZSI6ImFsZXhjaGVuIiwicGhvbmUiOiIxODM4ODg4ODg4OCJ9.0L2DzZz682cRh9WRb9S4GkcwXVWLAv9xeJFmGtIw-D4</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="jwt-安全性分析" tabindex="-1">JWT 安全性分析 <a class="header-anchor" href="#jwt-安全性分析" aria-label="Permalink to &quot;JWT 安全性分析&quot;">​</a></h2><p>在互联网中，通过 Http 协议传输数据主要有两大安全性危险：</p><ul><li>数据被窥探：通过敏感数据加密解决</li><li>数据被篡改：通过数据加签和验签解决</li></ul><p>JWT 通过对三部分数据进行加密，来防止直接明文传输，但是这不意味着安全，因为仍然可以通过技术手段解密，只是成本问题而已。</p><p>因此在 <code>payload</code> 部分传输明文敏感信息 (例如密码) 依然是不安全，可以通过对敏感信息进行不可逆加密，与数据库中使用同样算法的不可逆加密后的密文进行比较来达到验证敏感信息的功能。</p><p>另一方面，JWT 通过在第三部分增加签名，使用仅服务端存在的<strong>签名字符串</strong>，对 <code>head</code> 和 <code>payload</code> 部分进行加密，在服务端通过<strong>签名字符串</strong>解密签名并第一、二部分的 <code>head</code> 和 <code>payload</code> 进行比较，可以防止别人解密了 <code>head</code> 和 <code>payload</code> 后进行数据篡改。</p><h2 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h2><p>下列场景中使用 JSON Web Token 是很有用的：</p><ul><li><p>Authorization (授权) : 这是使用 JWT 的最常见场景。一旦用户登录，后续每个请求都将包含 JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的 JWT 的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</p></li><li><p>Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens 无疑是一种很好的方式。因为 JWT 可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</p></li></ul><h2 id="jwt-的使用方式" tabindex="-1">JWT 的使用方式 <a class="header-anchor" href="#jwt-的使用方式" aria-label="Permalink to &quot;JWT 的使用方式&quot;">​</a></h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息 <code>Authorization</code> 字段里面。</p><div class="language-yaml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#85E89D;">Authorization</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">Bearer &lt;token&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#22863A;">Authorization</span><span style="color:#24292E;">: </span><span style="color:#032F62;">Bearer &lt;token&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="jwt-的几个特点" tabindex="-1">JWT 的几个特点 <a class="header-anchor" href="#jwt-的几个特点" aria-label="Permalink to &quot;JWT 的几个特点&quot;">​</a></h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 <code>session</code> 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 <code>HTTPS</code> 协议传输。</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noreferrer">JSON Web Token 入门教程</a></li><li><a href="https://jwt.io/" target="_blank" rel="noreferrer">JWT 官方文档</a></li><li><a href="https://jwt.io/#debugger-io" target="_blank" rel="noreferrer">JWT debugger</a></li></ul>`,46),p=[o];function t(i,r,c,d,u,h){return a(),e("div",null,p)}const E=s(l,[["render",t]]);export{b as __pageData,E as default};
