const e=JSON.parse(`{"key":"v-d9ef6642","path":"/advance/algo/sort/1.2-quick.html","title":"1.2 快速排序","lang":"zh-CN","frontmatter":{"title":"1.2 快速排序","date":"2023-02-21T00:00:00.000Z","tag":["排序算法"],"category":"算法","description":"简介 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。","head":[["meta",{"property":"og:url","content":"https://github.com/AlexChen68/AlexChen68.github.io/advance/algo/sort/1.2-quick.html"}],["meta",{"property":"og:site_name","content":"AlexChen's Blog"}],["meta",{"property":"og:title","content":"1.2 快速排序"}],["meta",{"property":"og:description","content":"简介 快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。 快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-05T18:24:42.000Z"}],["meta",{"property":"article:author","content":"AlexChen"}],["meta",{"property":"article:tag","content":"排序算法"}],["meta",{"property":"article:published_time","content":"2023-02-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-05T18:24:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1.2 快速排序\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-02-21T00:00:00.000Z\\",\\"dateModified\\":\\"2023-04-05T18:24:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"AlexChen\\",\\"url\\":\\"https://github.com/AlexChen68\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"排序步骤","slug":"排序步骤","link":"#排序步骤","children":[]},{"level":2,"title":"演示动画","slug":"演示动画","link":"#演示动画","children":[]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]},{"level":2,"title":"复杂度分析","slug":"复杂度分析","link":"#复杂度分析","children":[]}],"git":{"createdTime":1680719082000,"updatedTime":1680719082000,"contributors":[{"name":"alexchen","email":"1274812218@qq.com","commits":1}]},"readingTime":{"minutes":4.81,"words":1443},"filePathRelative":"advance/algo/sort/1.2-quick.md","localizedDate":"2023年2月21日","excerpt":"<h2> 简介</h2>\\n<p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>\\n<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>\\n<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>","autoDesc":true}`);export{e as data};
