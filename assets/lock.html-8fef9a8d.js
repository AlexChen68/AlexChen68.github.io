const e=JSON.parse(`{"key":"v-4c1ac072","path":"/java/concurrency/juc/lock.html","title":"锁接口和类","lang":"zh-CN","frontmatter":{"title":"锁接口和类","category":"Concurrency","date":"2023-03-22T00:00:00.000Z","description":"前面我们介绍了 Java 原生的锁——基于对象的锁，它一般是配合 synchronized 关键字来使用的。实际上，Java 在java.util.concurrent.locks包下，还为我们提供了几个关于锁的类和接口。它们有更强大的功能或更高的性能。 synchronized 的不足之处 我们先来看看synchronized有什么不足之处。 如果临界区是只读操作，其实可以多线程一起执行，但使用 synchronized 的话，同一时间只能有一个线程执行。 synchronized 无法知道线程有没有成功获取到锁 使用 synchronized，如果临界区因为 IO 或者 sleep 方法等原因阻塞了，而当前线程又没有释放锁，就会导致所有线程等待。","head":[["meta",{"property":"og:url","content":"https://github.com/AlexChen68/AlexChen68.github.io/java/concurrency/juc/lock.html"}],["meta",{"property":"og:site_name","content":"AlexChen's Blog"}],["meta",{"property":"og:title","content":"锁接口和类"}],["meta",{"property":"og:description","content":"前面我们介绍了 Java 原生的锁——基于对象的锁，它一般是配合 synchronized 关键字来使用的。实际上，Java 在java.util.concurrent.locks包下，还为我们提供了几个关于锁的类和接口。它们有更强大的功能或更高的性能。 synchronized 的不足之处 我们先来看看synchronized有什么不足之处。 如果临界区是只读操作，其实可以多线程一起执行，但使用 synchronized 的话，同一时间只能有一个线程执行。 synchronized 无法知道线程有没有成功获取到锁 使用 synchronized，如果临界区因为 IO 或者 sleep 方法等原因阻塞了，而当前线程又没有释放锁，就会导致所有线程等待。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-04-01T09:07:24.000Z"}],["meta",{"property":"article:author","content":"AlexChen"}],["meta",{"property":"article:published_time","content":"2023-03-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-01T09:07:24.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"锁接口和类\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-22T00:00:00.000Z\\",\\"dateModified\\":\\"2023-04-01T09:07:24.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"AlexChen\\",\\"url\\":\\"https://github.com/AlexChen68\\"}]}"]]},"headers":[{"level":2,"title":"synchronized 的不足之处","slug":"synchronized-的不足之处","link":"#synchronized-的不足之处","children":[]},{"level":2,"title":"锁的几种分类","slug":"锁的几种分类","link":"#锁的几种分类","children":[{"level":3,"title":"可重入锁和非可重入锁","slug":"可重入锁和非可重入锁","link":"#可重入锁和非可重入锁","children":[]},{"level":3,"title":"公平锁与非公平锁","slug":"公平锁与非公平锁","link":"#公平锁与非公平锁","children":[]},{"level":3,"title":"读写锁和排它锁","slug":"读写锁和排它锁","link":"#读写锁和排它锁","children":[]}]},{"level":2,"title":"JDK 中有关锁的一些接口和类","slug":"jdk-中有关锁的一些接口和类","link":"#jdk-中有关锁的一些接口和类","children":[{"level":3,"title":"抽象类AQS/AQLS/AOS","slug":"抽象类aqs-aqls-aos","link":"#抽象类aqs-aqls-aos","children":[]},{"level":3,"title":"接口Condition/Lock/ReadWriteLock","slug":"接口condition-lock-readwritelock","link":"#接口condition-lock-readwritelock","children":[]},{"level":3,"title":"ReentrantLock","slug":"reentrantlock","link":"#reentrantlock","children":[]},{"level":3,"title":"ReentrantReadWriteLock","slug":"reentrantreadwritelock","link":"#reentrantreadwritelock","children":[]},{"level":3,"title":"StampedLock","slug":"stampedlock","link":"#stampedlock","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1680340044000,"updatedTime":1680340044000,"contributors":[{"name":"alexchen","email":"1274812218@qq.com","commits":1}]},"readingTime":{"minutes":12.21,"words":3662},"filePathRelative":"java/concurrency/juc/lock.md","localizedDate":"2023年3月22日","excerpt":"<p>前面我们介绍了 Java 原生的锁——基于对象的锁，它一般是配合 synchronized 关键字来使用的。实际上，Java 在<code>java.util.concurrent.locks</code>包下，还为我们提供了几个关于锁的类和接口。它们有更强大的功能或更高的性能。</p>\\n<h2> synchronized 的不足之处</h2>\\n<p>我们先来看看<code>synchronized</code>有什么不足之处。</p>\\n<ul>\\n<li>如果临界区是只读操作，其实可以多线程一起执行，但使用 synchronized 的话，<strong>同一时间只能有一个线程执行</strong>。</li>\\n<li>synchronized 无法知道线程有没有成功获取到锁</li>\\n<li>使用 synchronized，如果临界区因为 IO 或者 sleep 方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</li>\\n</ul>","autoDesc":true}`);export{e as data};
