import{_ as e,W as a,X as i,a1 as r}from"./framework-d3200c61.js";const h={},n=r('<h2 id="问题描述" tabindex="-1"><a class="header-anchor" href="#问题描述" aria-hidden="true">#</a> 问题描述</h2><blockquote><p>如何在 1 亿个数中找出最大的 10000 个数？</p></blockquote><h2 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法" aria-hidden="true">#</a> 解决方法</h2><h3 id="_1-快速排序法" tabindex="-1"><a class="header-anchor" href="#_1-快速排序法" aria-hidden="true">#</a> 1. 快速排序法</h3><p>直接对所有数据进行快速排序，然后取前 10000 个数，时间复杂度为 <em>O(nlong<sub>n</sub>)</em>。</p><p>机器内存可以撑住，但是效率不高，不推荐使用。</p><h3 id="_2-淘汰法" tabindex="-1"><a class="header-anchor" href="#_2-淘汰法" aria-hidden="true">#</a> 2. 淘汰法</h3><p>用一个 list 保存前 10000 个数字，然后遍历剩下的数字，如果某一个数字比容器中的最小值要大，就替换它。</p><p>从容器中找到最小值的时间复杂度是 <em>O(10000)</em>，替换一次之后，又需要重新找最小值；整体时间复杂度较高，不推荐使用。</p><h3 id="_3-分治法" tabindex="-1"><a class="header-anchor" href="#_3-分治法" aria-hidden="true">#</a> 3. 分治法</h3><ol><li>将 1 亿个数据分成 100 份，每份 100 万个数据；</li><li>然后使用多线程使用快速排序找出每份中 10000 个最大的数；</li><li>最后在找出的所有数据中，使用快速排序找出最大的 10000 个。</li></ol><p>这样可以提高 CPU 的利用率，大幅提高效率，推荐使用。</p><h3 id="_4-堆排序" tabindex="-1"><a class="header-anchor" href="#_4-堆排序" aria-hidden="true">#</a> 4. 堆排序</h3><ol><li>首先读取 10000 个数来构建一个<strong>最小堆</strong>（因为堆顶元素是堆里最小的，其他的都它大），建堆的时间复杂度为 <em>O(mlongm)</em> (m 为数组大小即为 10000)；</li><li>遍历其他的数据，如果小于堆顶元素，则用该元素替换它，然后重新构建最小堆；</li><li>重复上述步骤，直至所有数据被遍历完。</li><li>中序遍历堆得到的结果就是有序的。</li></ol><p>上述方法的时间复杂度为 <em>O(nmlogm)</em>，空间复杂度为 <em>O(10000)</em>，推荐使用。</p>',15),l=[n];function d(t,o){return a(),i("div",null,l)}const s=e(h,[["render",d],["__file","大数据量取前n个数.html.vue"]]);export{s as default};
