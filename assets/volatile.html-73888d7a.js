const e=JSON.parse(`{"key":"v-409ab37a","path":"/java/concurrency/principle/volatile.html","title":"volatile 关键字","lang":"zh-CN","frontmatter":{"title":"volatile 关键字","category":"Concurrency","date":"2023-03-17T00:00:00.000Z","description":"几个基本概念 在介绍 volatile 之前，我们先回顾及介绍几个基本的概念。 内存可见性 在 Java 内存模型那一章我们介绍了 JMM 有一个主内存，每个线程有自己私有的工作内存，工作内存中保存了一些变量在主内存的拷贝。 内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。 重排序 为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU 重排序等。","head":[["meta",{"property":"og:url","content":"https://github.com/AlexChen68/AlexChen68.github.io/java/concurrency/principle/volatile.html"}],["meta",{"property":"og:site_name","content":"AlexChen's Blog"}],["meta",{"property":"og:title","content":"volatile 关键字"}],["meta",{"property":"og:description","content":"几个基本概念 在介绍 volatile 之前，我们先回顾及介绍几个基本的概念。 内存可见性 在 Java 内存模型那一章我们介绍了 JMM 有一个主内存，每个线程有自己私有的工作内存，工作内存中保存了一些变量在主内存的拷贝。 内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。 重排序 为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU 重排序等。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-02T19:58:12.000Z"}],["meta",{"property":"article:author","content":"AlexChen"}],["meta",{"property":"article:published_time","content":"2023-03-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-06-02T19:58:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"volatile 关键字\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-17T00:00:00.000Z\\",\\"dateModified\\":\\"2023-06-02T19:58:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"AlexChen\\",\\"url\\":\\"https://github.com/AlexChen68\\"}]}"]]},"headers":[{"level":2,"title":"几个基本概念","slug":"几个基本概念","link":"#几个基本概念","children":[{"level":3,"title":"内存可见性","slug":"内存可见性","link":"#内存可见性","children":[]},{"level":3,"title":"重排序","slug":"重排序","link":"#重排序","children":[]},{"level":3,"title":"happens-before 规则","slug":"happens-before-规则","link":"#happens-before-规则","children":[]}]},{"level":2,"title":"volatile 的内存语义","slug":"volatile-的内存语义","link":"#volatile-的内存语义","children":[{"level":3,"title":"内存可见性","slug":"内存可见性-1","link":"#内存可见性-1","children":[]},{"level":3,"title":"禁止重排序","slug":"禁止重排序","link":"#禁止重排序","children":[]}]},{"level":2,"title":"volatile 的用途","slug":"volatile-的用途","link":"#volatile-的用途","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1680340044000,"updatedTime":1685735892000,"contributors":[{"name":"alexchen","email":"1274812218@qq.com","commits":2}]},"readingTime":{"minutes":8.27,"words":2480},"filePathRelative":"java/concurrency/principle/volatile.md","localizedDate":"2023年3月17日","excerpt":"<h2> 几个基本概念</h2>\\n<p>在介绍 volatile 之前，我们先回顾及介绍几个基本的概念。</p>\\n<h3> 内存可见性</h3>\\n<p>在 Java 内存模型那一章我们介绍了 JMM 有一个主内存，每个线程有自己私有的工作内存，工作内存中保存了一些变量在主内存的拷贝。</p>\\n<p><strong>内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值</strong>。</p>\\n<h3> 重排序</h3>\\n<p>为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU 重排序等。</p>","autoDesc":true}`);export{e as data};
