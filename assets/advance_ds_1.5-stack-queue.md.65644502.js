import{_ as e,o as t,c as d,Q as a}from"./chunks/framework.01af844e.js";const q=JSON.parse('{"title":"线性表 - 栈和队列","description":"","frontmatter":{"title":"线性表 - 栈和队列","date":"2023-04-01T00:00:00.000Z"},"headers":[],"relativePath":"advance/ds/1.5-stack-queue.md","filePath":"advance/ds/1.5-stack-queue.md","lastUpdated":1713403090000}'),r={name:"advance/ds/1.5-stack-queue.md"},o=a('<h2 id="栈和队列概述" tabindex="-1">栈和队列概述 <a class="header-anchor" href="#栈和队列概述" aria-label="Permalink to &quot;栈和队列概述&quot;">​</a></h2><ul><li><strong>栈</strong>：先入后出（LIFO）</li><li><strong>队列</strong>：先入先出（FIFO）</li></ul><p>栈和队列是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈和队列的功能）。</p><p>Java 里有一个叫做 Stack 的类，却没有叫做 Queue 的类 (它是个接口名字)。当需要使用栈时，Java 已不推荐使用 Stack，而是推荐使用更高效的 ArrayDeque；既然 Queue 只是一个接口，当需要使用队列时也就首选 ArrayDeque 了 (次选是 LinkedList)。</p><h2 id="常用的栈和队列的实现" tabindex="-1">常用的栈和队列的实现 <a class="header-anchor" href="#常用的栈和队列的实现" aria-label="Permalink to &quot;常用的栈和队列的实现&quot;">​</a></h2><ul><li>ArrayDeque</li><li>LinkedList</li></ul><p>它们都实现了 <code>Deque</code> 接口，其中 <code>ArrayDeque</code> 底层用数组实现，<code>LinkedList</code> 底层采用链表实现。</p><h3 id="queue-接口" tabindex="-1">Queue 接口 <a class="header-anchor" href="#queue-接口" aria-label="Permalink to &quot;Queue 接口&quot;">​</a></h3><p>Queue 接口继承自 Collection 接口，除了最基本的 Collection 的方法之外，它还支持额外的 insertion, extraction 和 inspection 操作。这里有两组格式，共 6 个方法，一组是抛出异常的实现；另外一组是返回值的实现 (没有则返回 null)。</p><table><thead><tr><th></th><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td><td>offer(e)</td></tr><tr><td>Remove</td><td>remove()</td><td>poll()</td></tr><tr><td>Examine</td><td>element()</td><td>peek()</td></tr></tbody></table><h3 id="deque-接口" tabindex="-1">Deque 接口 <a class="header-anchor" href="#deque-接口" aria-label="Permalink to &quot;Deque 接口&quot;">​</a></h3><p><code>Deque</code>是&quot;double ended queue&quot;, 表示双向的队列，英文读作&quot;deck&quot;. Deque 继承自 Queue 接口，除了支持 Queue 的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于 Deque 是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现 (没有则返回 null)。共 12 个方法如下：</p><table><thead><tr><th></th><th>First Element - Head</th><th></th><th>Last Element - Tail</th><th></th></tr></thead><tbody><tr><td></td><td>Throws exception</td><td>Special value</td><td>Throws exception</td><td>Special value</td></tr><tr><td>Insert</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr><td>Remove</td><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>Examine</td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><h3 id="deque-与-stack-和-queue-对应方法" tabindex="-1">Deque 与 Stack 和 Queue 对应方法 <a class="header-anchor" href="#deque-与-stack-和-queue-对应方法" aria-label="Permalink to &quot;Deque 与 Stack 和 Queue 对应方法&quot;">​</a></h3><p><em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口：</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>add(e)</code></td><td><code>addLast(e)</code></td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td><code>offer(e)</code></td><td><code>offerLast(e)</code></td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td><code>remove()</code></td><td><code>removeFirst()</code></td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td><code>poll()</code></td><td><code>pollFirst()</code></td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td><code>element()</code></td><td><code>getFirst()</code></td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>push(e)</code></td><td><code>addFirst(e)</code></td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>offerFirst(e)</code></td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFirst()</code></td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>pollFirst()</code></td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td><code>peek()</code></td><td><code>getFirst()</code></td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><h2 id="相关算法题" tabindex="-1">相关算法题 <a class="header-anchor" href="#相关算法题" aria-label="Permalink to &quot;相关算法题&quot;">​</a></h2><ul><li><a href="https://leetcode.cn/problems/min-stack/" target="_blank" rel="noreferrer">155. 最小栈</a></li><li><a href="https://leetcode.cn/problems/valid-parentheses/" target="_blank" rel="noreferrer">20. 有效的括号</a></li><li><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noreferrer">1047. 删除字符串中的所有相邻重复项</a></li><li><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noreferrer">150. 逆波兰表达式求值</a></li><li><a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank" rel="noreferrer">239. 滑动窗口最大值</a></li><li><a href="https://leetcode.cn/problems/top-k-frequent-elements/" target="_blank" rel="noreferrer">347. 前 K 个高频元素</a></li></ul><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://pdai.tech/md/java/collection/java-collection-Queue&amp;Stack.html" target="_blank" rel="noreferrer">Collection - Stack &amp; Queue 源码解析</a></li></ul>',22),l=[o];function c(i,u,n,s,h,p){return t(),d("div",null,l)}const b=e(r,[["render",c]]);export{q as __pageData,b as default};
