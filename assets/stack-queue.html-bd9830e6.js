import{_ as o,W as a,X as c,Y as e,a0 as t,Z as r,a1 as l,C as n}from"./framework-d3200c61.js";const s={},i=l('<h2 id="栈和队列概述" tabindex="-1"><a class="header-anchor" href="#栈和队列概述" aria-hidden="true">#</a> 栈和队列概述</h2><ul><li><strong>栈</strong>：先入后出（LIFO）</li><li><strong>队列</strong>：先入先出（FIFO）</li></ul><p>栈和队列是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈和队列的功能）。</p><p>Java 里有一个叫做 Stack 的类，却没有叫做 Queue 的类 (它是个接口名字)。当需要使用栈时，Java 已不推荐使用 Stack，而是推荐使用更高效的 ArrayDeque；既然 Queue 只是一个接口，当需要使用队列时也就首选 ArrayDeque 了 (次选是 LinkedList)。</p><h2 id="常用的栈和队列的实现" tabindex="-1"><a class="header-anchor" href="#常用的栈和队列的实现" aria-hidden="true">#</a> 常用的栈和队列的实现</h2><ul><li>ArrayDeque</li><li>LinkedList</li></ul><p>它们都实现了 <code>Deque</code> 接口，其中 <code>ArrayDeque</code> 底层用数组实现，<code>LinkedList</code> 底层采用链表实现。</p><h3 id="queue-接口" tabindex="-1"><a class="header-anchor" href="#queue-接口" aria-hidden="true">#</a> Queue 接口</h3><p>Queue 接口继承自 Collection 接口，除了最基本的 Collection 的方法之外，它还支持额外的 insertion, extraction 和 inspection 操作。这里有两组格式，共 6 个方法，一组是抛出异常的实现；另外一组是返回值的实现 (没有则返回 null)。</p><table><thead><tr><th></th><th>Throws exception</th><th>Returns special value</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td><td>offer(e)</td></tr><tr><td>Remove</td><td>remove()</td><td>poll()</td></tr><tr><td>Examine</td><td>element()</td><td>peek()</td></tr></tbody></table><h3 id="deque-接口" tabindex="-1"><a class="header-anchor" href="#deque-接口" aria-hidden="true">#</a> Deque 接口</h3><p><code>Deque</code>是&quot;double ended queue&quot;, 表示双向的队列，英文读作&quot;deck&quot;. Deque 继承自 Queue 接口，除了支持 Queue 的方法之外，还支持<code>insert</code>, <code>remove</code>和<code>examine</code>操作，由于 Deque 是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现 (没有则返回 null)。共 12 个方法如下：</p><table><thead><tr><th></th><th>First Element - Head</th><th></th><th>Last Element - Tail</th><th></th></tr></thead><tbody><tr><td></td><td>Throws exception</td><td>Special value</td><td>Throws exception</td><td>Special value</td></tr><tr><td>Insert</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr><td>Remove</td><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>Examine</td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><h3 id="deque-与-stack-和-queue-对应方法" tabindex="-1"><a class="header-anchor" href="#deque-与-stack-和-queue-对应方法" aria-hidden="true">#</a> Deque 与 Stack 和 Queue 对应方法</h3><p><em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口：</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>add(e)</code></td><td><code>addLast(e)</code></td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td><code>offer(e)</code></td><td><code>offerLast(e)</code></td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td><code>remove()</code></td><td><code>removeFirst()</code></td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td><code>poll()</code></td><td><code>pollFirst()</code></td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td><code>element()</code></td><td><code>getFirst()</code></td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>push(e)</code></td><td><code>addFirst(e)</code></td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>offerFirst(e)</code></td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFirst()</code></td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>pollFirst()</code></td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td><code>peek()</code></td><td><code>getFirst()</code></td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><h2 id="相关算法题" tabindex="-1"><a class="header-anchor" href="#相关算法题" aria-hidden="true">#</a> 相关算法题</h2>',19),h={href:"https://leetcode.cn/problems/min-stack/",target:"_blank",rel:"noopener noreferrer"},u={href:"https://leetcode.cn/problems/valid-parentheses/",target:"_blank",rel:"noopener noreferrer"},p={href:"https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://leetcode.cn/problems/evaluate-reverse-polish-notation/",target:"_blank",rel:"noopener noreferrer"},f={href:"https://leetcode.cn/problems/sliding-window-maximum/",target:"_blank",rel:"noopener noreferrer"},_={href:"https://leetcode.cn/problems/top-k-frequent-elements/",target:"_blank",rel:"noopener noreferrer"},b=e("h2",{id:"参考资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),t(" 参考资料")],-1),k={href:"https://pdai.tech/md/java/collection/java-collection-Queue&Stack.html",target:"_blank",rel:"noopener noreferrer"};function q(v,x){const d=n("ExternalLinkIcon");return a(),c("div",null,[i,e("ul",null,[e("li",null,[e("a",h,[t("155. 最小栈"),r(d)])]),e("li",null,[e("a",u,[t("20. 有效的括号"),r(d)])]),e("li",null,[e("a",p,[t("1047. 删除字符串中的所有相邻重复项"),r(d)])]),e("li",null,[e("a",m,[t("150. 逆波兰表达式求值"),r(d)])]),e("li",null,[e("a",f,[t("239. 滑动窗口最大值"),r(d)])]),e("li",null,[e("a",_,[t("347. 前 K 个高频元素"),r(d)])])]),b,e("ul",null,[e("li",null,[e("a",k,[t("Collection - Stack & Queue 源码解析"),r(d)])])])])}const L=o(s,[["render",q],["__file","stack-queue.html.vue"]]);export{L as default};
