import{_ as o,C as r,o as t,c as l,k as e,a as n,H as i,Q as c}from"./chunks/framework.419948d5.js";const x=JSON.parse('{"title":"并发理论基础","description":"","frontmatter":{"title":"并发理论基础","article":false,"date":"2023-03-13T00:00:00.000Z"},"headers":[],"relativePath":"java/concurrency/principle/index.md","filePath":"java/concurrency/principle/index.md","lastUpdated":1695845670000}'),s={name:"java/concurrency/principle/index.md"},d=c('<h2 id="什么是并发" tabindex="-1">什么是并发？ <a class="header-anchor" href="#什么是并发" aria-label="Permalink to &quot;什么是并发？&quot;">​</a></h2><p>CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；// 导致<strong>可见性</strong>问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致<strong>原子性</strong>问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。// 导致<strong>有序性</strong>问题</li></ul><h2 id="并发带来的安全问题" tabindex="-1">并发带来的安全问题 <a class="header-anchor" href="#并发带来的安全问题" aria-label="Permalink to &quot;并发带来的安全问题&quot;">​</a></h2><ol><li><strong>可见性问题</strong></li></ol><blockquote><p>可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></blockquote><p>在并发的时候，多个线程同时对一个共享变量进行修改操作，如果执行操作的两个线程不在一个 CPU 核心上，那么由于 CPU 高速缓存的存在，一个线程修改后的值，无法及时被另一个线程获知，导致最终结果不符合预期。</p><ol start="2"><li><strong>原子性问题</strong></li></ol><blockquote><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>原子操作：即不会被线程调度机制打断的操作，没有上下文切换。</p></blockquote><ol start="3"><li><strong>有序性问题</strong></li></ol><blockquote><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p></blockquote><h2 id="怎么解决上述问题" tabindex="-1">怎么解决上述问题？ <a class="header-anchor" href="#怎么解决上述问题" aria-label="Permalink to &quot;怎么解决上述问题？&quot;">​</a></h2><p>JMM 本质上可以理解为，Java 内存模型规范了 JVM 如何提供<strong>按需禁用缓存</strong>和<strong>编译优化</strong>的方法。具体来说，这些方法包括：</p><ul><li>volatile、synchronized 和 final 三个关键字</li><li>Happens-Before 规则</li></ul><h3 id="解决原子性问题" tabindex="-1">解决原子性问题 <a class="header-anchor" href="#解决原子性问题" aria-label="Permalink to &quot;解决原子性问题&quot;">​</a></h3><p>在 Java 中，对基本数据类型的变量的<strong>读取</strong>和<strong>赋值</strong>操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><p>如果要实现更大范围操作的原子性，可以通过 <code>synchronized</code> 和 <code>Lock</code> 来实现。由于 <code>synchronized</code> 和 <code>Lock</code> 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><h3 id="解决可见性问题" tabindex="-1">解决可见性问题 <a class="header-anchor" href="#解决可见性问题" aria-label="Permalink to &quot;解决可见性问题&quot;">​</a></h3><ol><li>Java 提供了 <code>volatile</code> 关键字来保证可见性。</li></ol><p>当一个共享变量被 <code>volatile</code> 修饰时，它会<strong>保证修改的值会立即被更新到主存</strong>，当有其他线程需要读取时，它会去内存中读取新值。</p><ol start="2"><li>另外，通过 <code>synchronized</code> 和 <code>Lock</code> 也能够保证可见性，<code>synchronized</code> 和 <code>Lock</code> 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</li></ol><h3 id="解决有序性问题" tabindex="-1">解决有序性问题 <a class="header-anchor" href="#解决有序性问题" aria-label="Permalink to &quot;解决有序性问题&quot;">​</a></h3><p>在 Java 里面，可以通过 <code>volatile</code> 关键字来保证一定的“有序性”。另外可以通过 <code>synchronized</code> 和 <code>Lock</code> 来保证有序性，很显然，<code>synchronized</code> 和 <code>Lock</code> 保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然 JMM 是通过 <code>Happens-Before</code> 规则来保证有序性的。</p><h3 id="happens-before-原则" tabindex="-1">Happens-Before 原则 <a class="header-anchor" href="#happens-before-原则" aria-label="Permalink to &quot;Happens-Before 原则&quot;">​</a></h3><p>在 Java 中，有以下天然的 happens-before 关系：</p><ul><li>程序顺序规则：一个线程中的每一个操作，happens-before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li><li>start 规则：如果线程 A 执行操作 ThreadB.start() 启动线程 B，那么 A 线程的 ThreadB.start（）操作 happens-before 于线程 B 中的任意操作、</li><li>join 规则：如果线程 A 执行操作 ThreadB.join（）并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回。</li></ul><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2>',27),h=e("a",{href:"https://pdai.tech/md/java/thread/java-thread-x-theorty.html",target:"_blank",rel:"noreferrer"},"Java 并发理论基础",-1),p=e("li",null,[e("a",{href:"https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html",target:"_blank",rel:"noreferrer"},"Lesson: Concurrency (The Java™ Tutorials > Essential Java Classes) (oracle.com)")],-1),u=e("li",null,[e("a",{href:"https://blog.csdn.net/m0_73311735/article/details/127919267",target:"_blank",rel:"noreferrer"},"Java 并发编程之可见性分析 volatile")],-1);function f(b,_,g,k,v,m){const a=r("Badge");return t(),l("div",null,[d,e("ul",null,[e("li",null,[h,n(),i(a,{text:"推荐",type:"tip"})]),p,u])])}const P=o(s,[["render",f]]);export{x as __pageData,P as default};
