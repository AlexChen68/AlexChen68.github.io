import{_ as l,C as p,o as e,c as o,k as s,a,H as t,Q as c}from"./chunks/framework.419948d5.js";const D=JSON.parse('{"title":"160. 相交链表","description":"","frontmatter":{"title":"160. 相交链表","tag":["链表","双指针"],"date":"2023-03-17T00:00:00.000Z"},"headers":[],"relativePath":"advance/LeetCode/160-相交链表.md","filePath":"advance/LeetCode/160-相交链表.md","lastUpdated":1697769685000}'),r={name:"advance/LeetCode/160-相交链表.md"},E=s("h2",{id:"题目链接",tabindex:"-1"},[a("题目链接 "),s("a",{class:"header-anchor",href:"#题目链接","aria-label":'Permalink to "题目链接"'},"​")],-1),i=s("ul",null,[s("li",null,[s("a",{href:"https://leetcode.cn/problems/intersection-of-two-linked-lists",target:"_blank",rel:"noreferrer"},"160. 相交链表")])],-1),y={id:"题目描述",tabindex:"-1"},d=s("a",{class:"header-anchor",href:"#题目描述","aria-label":'Permalink to "题目描述 <Badge text="简单" type="tip"/>"'},"​",-1),h=c(`<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code>，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code>。</p><p>图示两个链表在节点 <code>c1</code> 开始相交：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="pic"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" alt="示例 "></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">输出：2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">输出：2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="解题思路" tabindex="-1">解题思路 <a class="header-anchor" href="#解题思路" aria-label="Permalink to &quot;解题思路&quot;">​</a></h2><p>方法一：遍历其中一个链表，用 HashMap 存储链表节点，再遍历另一个判断是否含有该结点，这里主要介绍方法二；</p><p>方法二：<strong>双指针</strong></p><p>如果两个链表相交，那么相交点之后的长度是相同的；我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。为此，我们必须消除两个链表的长度差：</p><ul><li>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</li><li>如果 pA 到了末尾，则 pA = headB 继续遍历</li><li>如果 pB 到了末尾，则 pB = headA 继续遍历</li><li>比较长的链表指针指向较短链表 head 时，长度差就消除了</li><li>如此，只需要将最短链表遍历两次即可找到位置</li></ul><p>如图所示：</p><p><img src="https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png" alt=""></p><h2 id="示例代码" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码" aria-label="Permalink to &quot;示例代码&quot;">​</a></h2><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> ListNode </span><span style="color:#B392F0;">getIntersectionNode</span><span style="color:#E1E4E8;">(ListNode </span><span style="color:#FFAB70;">headA</span><span style="color:#E1E4E8;">, ListNode </span><span style="color:#FFAB70;">headB</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (headA </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> headB </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">         ListNode a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> headA;</span></span>
<span class="line"><span style="color:#E1E4E8;">         ListNode b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> headB;</span></span>
<span class="line"><span style="color:#E1E4E8;">         </span><span style="color:#6A737D;">// 互换之后，a 和 b 距离各自末尾的距离一样，如果不想交，最后都会等于 null，退出循环</span></span>
<span class="line"><span style="color:#E1E4E8;">         </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (a </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> b) {</span></span>
<span class="line"><span style="color:#E1E4E8;">             a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (a </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> headB </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> a.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">             b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (b </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> headA </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> b.next;</span></span>
<span class="line"><span style="color:#E1E4E8;">         }</span></span>
<span class="line"><span style="color:#E1E4E8;">         </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> ListNode </span><span style="color:#6F42C1;">getIntersectionNode</span><span style="color:#24292E;">(ListNode </span><span style="color:#E36209;">headA</span><span style="color:#24292E;">, ListNode </span><span style="color:#E36209;">headB</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (headA </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> headB </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">         ListNode a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> headA;</span></span>
<span class="line"><span style="color:#24292E;">         ListNode b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> headB;</span></span>
<span class="line"><span style="color:#24292E;">         </span><span style="color:#6A737D;">// 互换之后，a 和 b 距离各自末尾的距离一样，如果不想交，最后都会等于 null，退出循环</span></span>
<span class="line"><span style="color:#24292E;">         </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (a </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> b) {</span></span>
<span class="line"><span style="color:#24292E;">             a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (a </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> headB </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> a.next;</span></span>
<span class="line"><span style="color:#24292E;">             b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (b </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> headA </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> b.next;</span></span>
<span class="line"><span style="color:#24292E;">         }</span></span>
<span class="line"><span style="color:#24292E;">         </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="复杂度分析" tabindex="-1">复杂度分析 <a class="header-anchor" href="#复杂度分析" aria-label="Permalink to &quot;复杂度分析&quot;">​</a></h2><ul><li>空间复杂度 O(1)</li><li>时间复杂度为 O(n)</li></ul>`,19);function u(b,m,A,_,F,B){const n=p("Badge");return e(),o("div",null,[E,i,s("h2",y,[a("题目描述 "),t(n,{text:"简单",type:"tip"}),a(),d]),h])}const v=l(r,[["render",u]]);export{D as __pageData,v as default};
