import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.419948d5.js";const h=JSON.parse('{"title":"线性表 - 链表","description":"","frontmatter":{"title":"线性表 - 链表","date":"2022-09-27T00:00:00.000Z"},"headers":[],"relativePath":"advance/ds/1.2-linkedlist.md","filePath":"advance/ds/1.2-linkedlist.md","lastUpdated":1695217340000}'),p={name:"advance/ds/1.2-linkedlist.md"},e=l(`<h2 id="链表概述" tabindex="-1">链表概述 <a class="header-anchor" href="#链表概述" aria-label="Permalink to &quot;链表概述&quot;">​</a></h2><p>链表是一种通过指针串联在一起的线性结构，每一个结点由两部分组成，一个是数据域一个是指针域（存放指向下一个结点的指针），最后一个结点的指针域指向 null（空指针的意思）。</p><p>链表的入口结点称为链表的头结点也就是 head。</p><p>上面讲的是我们最常见的单向链表，实际上链表还可以分为：</p><ul><li>单向链表：一个结点指向下一个结点。</li></ul><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png" alt="单向链表"></p><ul><li>双向链表：每一个结点有两个指针域，一个指向下一个结点，一个指向上一个结点。</li></ul><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png" alt="双向链表"></p><ul><li>循环链表：能通过任何一个结点找到其他所有的结点，将两种 (双向/单向) 链表的最后一个结点指向第一个结点从而实现循环。</li></ul><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png" alt="循环链表"></p><h2 id="链表的存储方式" tabindex="-1">链表的存储方式 <a class="header-anchor" href="#链表的存储方式" aria-label="Permalink to &quot;链表的存储方式&quot;">​</a></h2><p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p><p>链表是通过指针域的指针链接在内存中各个结点。</p><p>所以链表中的结点在内存中不是连续分布的，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194613920.png" alt="链表存储方式"></p><h2 id="链表的定义" tabindex="-1">链表的定义 <a class="header-anchor" href="#链表的定义" aria-label="Permalink to &quot;链表的定义&quot;">​</a></h2><p>单向链表的定义</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ListNode</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 结点的值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> val;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 下一个结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    ListNode next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 节点的构造函数 (无参)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ListNode</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 节点的构造函数 (有一个参数)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ListNode</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">val</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.val </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> val;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 节点的构造函数 (有两个参数)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ListNode</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">val</span><span style="color:#E1E4E8;">, ListNode </span><span style="color:#FFAB70;">next</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.val </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> val;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ListNode</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 结点的值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> val;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 下一个结点</span></span>
<span class="line"><span style="color:#24292E;">    ListNode next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 节点的构造函数 (无参)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ListNode</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 节点的构造函数 (有一个参数)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ListNode</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">val</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> val;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 节点的构造函数 (有两个参数)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ListNode</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">val</span><span style="color:#24292E;">, ListNode </span><span style="color:#E36209;">next</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> val;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h2 id="链表的操作" tabindex="-1">链表的操作 <a class="header-anchor" href="#链表的操作" aria-label="Permalink to &quot;链表的操作&quot;">​</a></h2><p>下述的操作都默认为单向链表</p><p><strong>添加结点</strong></p><p>在链表中添加结点，需要先从头结点遍历至要插入位置的上一个结点，通过改变其指针至待添加的结点，以及将待添加的结点指向要插入位置原来的结点来实现，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195134331-20230310121503147.png" alt="添加结点"></p><p><strong>删除结点</strong></p><p>在链表中删除结点，需要进行和添加结点正好相反的操作，但是都需要先遍历到要删除的结点的上一个结点（因为结点的引用在上一个结点），然后将上一个结点的指针，直接指向待删除结点再下一个结点，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195114541-20230310121459257.png" alt="删除结点"></p><h2 id="链表的性能" tabindex="-1">链表的性能 <a class="header-anchor" href="#链表的性能" aria-label="Permalink to &quot;链表的性能&quot;">​</a></h2><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p><p>链表的长度可以是不固定的，并且可以动态增删，适合数据量不固定，频繁增删，较少查询的场景。</p><h2 id="相关算法题" tabindex="-1">相关算法题 <a class="header-anchor" href="#相关算法题" aria-label="Permalink to &quot;相关算法题&quot;">​</a></h2><p>解链表相关算法题常用的技巧：</p><ol><li>虚拟头结点</li><li>双指针/快慢指针</li><li>递归</li></ol><ul><li><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noreferrer">019. 删除链表的倒数第 N 个结点</a></li><li><a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noreferrer">142. 环形链表 II</a></li><li><a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noreferrer">206. 反转链表</a></li><li><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists" target="_blank" rel="noreferrer">160. 相交链表</a></li><li><a href="https://leetcode.cn/problems/merge-k-sorted-lists/" target="_blank" rel="noreferrer">23. 合并 K 个升序链表</a></li></ul><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html" target="_blank" rel="noreferrer">链表理论基础</a></li></ul>`,36),o=[e];function t(r,c,i,E,y,d){return n(),a("div",null,o)}const u=s(p,[["render",t]]);export{h as __pageData,u as default};
