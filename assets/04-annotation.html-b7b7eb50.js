import{_ as a,W as e,X as i,Y as n,$ as l}from"./framework-3160f2a1.js";const r={},t=l(`<h2 id="java-注解" tabindex="-1"><a class="header-anchor" href="#java-注解" aria-hidden="true">#</a> Java 注解</h2><h3 id="什么是注解" tabindex="-1"><a class="header-anchor" href="#什么是注解" aria-hidden="true">#</a> 什么是注解</h3><p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。</p><p><strong>注解的优点</strong>：</p><ol><li>通过使用注解，你可以将元数据保存在 Java 源代码中。</li><li>简单易读的代码。</li><li>编译器类型检查。</li><li>使用 annotation API 为自己的注解构造处理工具。</li></ol><p>在 <code>java.lang</code> 包中，<strong>内置</strong>了一些注解：</p><ul><li>@Override:表示当前的方法定义将覆盖基类的方法。如果你不小心拼写错误，或 者方法签名被错误拼写的时候，编译器就会发出错误提示。</li><li>@Deprecated:如果使用该注解的元素被调用，编译器就会发出警告信息。</li><li>@SuppressWarnings:关闭不当的编译器警告信息。</li><li>@SafeVarargs:在 Java 7 中加入用于禁止对具有泛型 varargs 参数的方法或构造函数的调用方发出警告。</li><li>@FunctionalInterface:Java 8 中加入用于表示类型声明为函数式接口。</li></ul><p>此外，在 <code>java.lang.annotaion</code> 包下还有几种额外的注解类型用于创造新的注解：</p><ul><li>@Target 定义你的注解可以应用在哪里(例如是方法还是字段)。</li><li>@Retention 定义了注解在哪里可用，在源代码中(SOURCE)，class 文件(CLASS)中或者是在运行时(RUNTIME)。</li></ul><h3 id="定义注解" tabindex="-1"><a class="header-anchor" href="#定义注解" aria-hidden="true">#</a> 定义注解</h3><p>如下是一个注解的定义。注解的定义看起来很像接口的定义。事实上，它们和其他 Java 接口一样，也会被编译成 class 文件。</p><div class="language-java" data-ext="java"><pre class="language-java"><code>
</code></pre></div>`,12);function o(s,c){return e(),i("div",null,[n(" more "),t])}const h=a(r,[["render",o],["__file","04-annotation.html.vue"]]);export{h as default};
