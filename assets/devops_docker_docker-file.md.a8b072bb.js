import{_ as e,o as t,c as s,Q as a}from"./chunks/framework.01af844e.js";const m=JSON.parse('{"title":"Dockerfile","description":"","frontmatter":{"title":"Dockerfile","date":"2023-01-28T00:00:00.000Z","order":3},"headers":[],"relativePath":"devops/docker/docker-file.md","filePath":"devops/docker/docker-file.md","lastUpdated":1731900098000}'),d={name:"devops/docker/docker-file.md"},o=a(`<h1 id="dockerfile" tabindex="-1">Dockerfile <a class="header-anchor" href="#dockerfile" aria-label="Permalink to &quot;Dockerfile&quot;">​</a></h1><h2 id="什么是-dockerfile" tabindex="-1">什么是 Dockerfile？ <a class="header-anchor" href="#什么是-dockerfile" aria-label="Permalink to &quot;什么是 Dockerfile？&quot;">​</a></h2><p>Docker 镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的 指令 (Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><h2 id="dockerfile-文件格式" tabindex="-1">Dockerfile 文件格式 <a class="header-anchor" href="#dockerfile-文件格式" aria-label="Permalink to &quot;Dockerfile 文件格式&quot;">​</a></h2><table><thead><tr><th>指令</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>FROM</td><td>image</td><td>指定基础镜像</td></tr><tr><td>MAINTAINER</td><td>name</td><td>镜像维护者信息</td></tr><tr><td>RUN</td><td>command</td><td>在容器内部执行命令</td></tr><tr><td>CMD</td><td>command</td><td>容器启动时执行命令</td></tr><tr><td>EXPOSE</td><td>port</td><td>声明容器需要监听的端口</td></tr><tr><td>ENV</td><td>key=value</td><td>设置环境变量</td></tr><tr><td>ADD</td><td>src dest</td><td>复制文件或目录到容器内部</td></tr><tr><td>COPY</td><td>src dest</td><td>复制文件或目录到容器内部</td></tr><tr><td>ENTRYPOINT</td><td>command</td><td>容器启动时执行的命令</td></tr><tr><td>VOLUME</td><td>path</td><td>声明数据卷</td></tr><tr><td>USER</td><td>username</td><td>指定容器运行的用户名</td></tr><tr><td>WORKDIR</td><td>path</td><td>指定容器的工作目录</td></tr><tr><td>ARG</td><td>name</td><td>设置构建时的参数</td></tr><tr><td>ONBUILD</td><td>command</td><td>当镜像被用作其他镜像的基础镜像时执行的命令</td></tr></tbody></table><h2 id="构建镜像" tabindex="-1">构建镜像 <a class="header-anchor" href="#构建镜像" aria-label="Permalink to &quot;构建镜像&quot;">​</a></h2><p>docker 使用 dockerfile 构建镜像的命令格式为：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">docker build [选项] &lt;上下文路径/URL/-&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">docker build [选项] &lt;上下文路径/URL/-&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><em>其中上下文路径为 <code>Dockerfile</code> 文件所在路径。</em></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>其中上下文路径并不是 <code>Dockerfile</code> 文件所在路径，而是<strong>上下文路径</strong>；</p><p>当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>因为有了上下文路径，我们才能在 <code>ADD</code> 和 <code>COPY</code> 命令中，获取到需要打包的文件路径。</p></div><p>示例：</p><div class="language-dockerfile vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> nginx</span></span>
<span class="line"><span style="color:#F97583;">RUN</span><span style="color:#E1E4E8;"> echo </span><span style="color:#9ECBFF;">&#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39;</span><span style="color:#E1E4E8;"> &gt; /usr/share/nginx/html/index.html</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> nginx</span></span>
<span class="line"><span style="color:#D73A49;">RUN</span><span style="color:#24292E;"> echo </span><span style="color:#032F62;">&#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39;</span><span style="color:#24292E;"> &gt; /usr/share/nginx/html/index.html</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在 <code>Dockerfile</code> 文件所在目录，执行以下命令，将使用当前目录下的 <code>Dockerfile</code> 文件构建一个 nginx 镜像，版本为 v3:</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">docker</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">build</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-t</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">nginx:v3</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">.</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">docker</span><span style="color:#24292E;"> </span><span style="color:#032F62;">build</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-t</span><span style="color:#24292E;"> </span><span style="color:#032F62;">nginx:v3</span><span style="color:#24292E;"> </span><span style="color:#032F62;">.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>`,15),l=[o];function r(n,c,p,i,h,k){return t(),s("div",null,l)}const b=e(d,[["render",r]]);export{m as __pageData,b as default};
