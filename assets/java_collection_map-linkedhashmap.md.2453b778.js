import{_ as s,o as a,c as n,Q as l}from"./chunks/framework.419948d5.js";const u=JSON.parse('{"title":"Map - LinkedHashMap 源码分析","description":"","frontmatter":{"title":"Map - LinkedHashMap 源码分析","date":"2022-09-30T00:00:00.000Z","order":7},"headers":[],"relativePath":"java/collection/map-linkedhashmap.md","filePath":"java/collection/map-linkedhashmap.md","lastUpdated":1699298916000}'),p={name:"java/collection/map-linkedhashmap.md"},e=l(`<h1 id="linkedhashmap" tabindex="-1">LinkedHashMap <a class="header-anchor" href="#linkedhashmap" aria-label="Permalink to &quot;LinkedHashMap&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p><code>HashMap</code> 是哈希表的无序实现，<code>LinkedHashMap</code> 在 <code>HashMap</code> 的基础之上，提供了顺序访问的特性。而这里的顺序，包括两种：</p><ol><li>按照 key-value 的插入顺序进行访问;</li><li>按照 key-value 的访问顺序进行访问（LRU 算法）。</li></ol><h2 id="类图" tabindex="-1">类图 <a class="header-anchor" href="#类图" aria-label="Permalink to &quot;类图&quot;">​</a></h2><p><img src="https://cdn.jsdelivr.net/gh/AlexChen68/OSS@master/blog/java/linkedhashmap_class.png" alt="LinkedHashMap 类图" title=":size=60%"></p><p><code>LinkedHashMap</code> 实现 <code>java.util.Map</code> 接口，继承了 <code>java.util.HashMap</code> 类。</p><h2 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h2><p>实例属性</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 头结点（越老的节点，放在越前面。所以头节点，指向链表的开头）</span></span>
<span class="line"><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> LinkedHashMap.Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; head;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 尾结点（越新的节点，放在越后面。所以尾节点，指向链表的结尾）</span></span>
<span class="line"><span style="color:#F97583;">transient</span><span style="color:#E1E4E8;"> LinkedHashMap.Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; tail;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * 是否按访问顺序排序，默认为 false</span></span>
<span class="line"><span style="color:#6A737D;"> * true：按照 key-value 的访问顺序进行访问</span></span>
<span class="line"><span style="color:#6A737D;"> * false：按照 key-value 的插入顺序进行访问</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> accessOrder;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 头结点（越老的节点，放在越前面。所以头节点，指向链表的开头）</span></span>
<span class="line"><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> LinkedHashMap.Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; head;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 尾结点（越新的节点，放在越后面。所以尾节点，指向链表的结尾）</span></span>
<span class="line"><span style="color:#D73A49;">transient</span><span style="color:#24292E;"> LinkedHashMap.Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; tail;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * 是否按访问顺序排序，默认为 false</span></span>
<span class="line"><span style="color:#6A737D;"> * true：按照 key-value 的访问顺序进行访问</span></span>
<span class="line"><span style="color:#6A737D;"> * false：按照 key-value 的插入顺序进行访问</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> accessOrder;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="内部类" tabindex="-1">内部类 <a class="header-anchor" href="#内部类" aria-label="Permalink to &quot;内部类&quot;">​</a></h2><p><code>LinkedHashMap</code> 的 <code>Entry&lt;K,V&gt;</code> 继承自 <code>HashMap</code> 的 <code>Node&lt;K,V&gt;</code></p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Entry</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HashMap.Node</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 前一个结点；后一个结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; before, after;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 构造方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">Entry</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">hash</span><span style="color:#E1E4E8;">, K </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, V </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">, Node&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">next</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(hash, key, value, next);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Entry</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HashMap.Node</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 前一个结点；后一个结点</span></span>
<span class="line"><span style="color:#24292E;">    Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; before, after;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 构造方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">Entry</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">hash</span><span style="color:#24292E;">, K </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, V </span><span style="color:#E36209;">value</span><span style="color:#24292E;">, Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">next</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(hash, key, value, next);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="构造方法" tabindex="-1">构造方法 <a class="header-anchor" href="#构造方法" aria-label="Permalink to &quot;构造方法&quot;">​</a></h2><p><code>LinkedHashMap</code> 的构造和 <code>HashMap</code> 的差不多，只是在 <code>HashMap</code> 的构造方法上多加了 <code>accessOrder = false</code> ，说明默认使用按插入顺序排序。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LinkedHashMap</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> initialCapacity, </span><span style="color:#F97583;">float</span><span style="color:#E1E4E8;"> loadFactor) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(initialCapacity, loadFactor);</span></span>
<span class="line"><span style="color:#E1E4E8;">    accessOrder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LinkedHashMap</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> initialCapacity) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(initialCapacity);</span></span>
<span class="line"><span style="color:#E1E4E8;">    accessOrder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LinkedHashMap</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    accessOrder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LinkedHashMap</span><span style="color:#E1E4E8;">(Map</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends K, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> m) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    accessOrder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">putMapEntries</span><span style="color:#E1E4E8;">(m, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LinkedHashMap</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> initialCapacity, </span><span style="color:#D73A49;">float</span><span style="color:#24292E;"> loadFactor) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(initialCapacity, loadFactor);</span></span>
<span class="line"><span style="color:#24292E;">    accessOrder </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LinkedHashMap</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> initialCapacity) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(initialCapacity);</span></span>
<span class="line"><span style="color:#24292E;">    accessOrder </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LinkedHashMap</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    accessOrder </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LinkedHashMap</span><span style="color:#24292E;">(Map</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends K, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> m) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    accessOrder </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">putMapEntries</span><span style="color:#24292E;">(m, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>另外，<code>LinkedHashMap</code> 增加了一个构造方法，可以指定 <code>accessOrder</code> 来决定使用哪种排序：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LinkedHashMap</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> initialCapacity,</span></span>
<span class="line"><span style="color:#E1E4E8;">                     </span><span style="color:#F97583;">float</span><span style="color:#E1E4E8;"> loadFactor,</span></span>
<span class="line"><span style="color:#E1E4E8;">                     </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> accessOrder) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(initialCapacity, loadFactor);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.accessOrder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> accessOrder;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LinkedHashMap</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> initialCapacity,</span></span>
<span class="line"><span style="color:#24292E;">                     </span><span style="color:#D73A49;">float</span><span style="color:#24292E;"> loadFactor,</span></span>
<span class="line"><span style="color:#24292E;">                     </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> accessOrder) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(initialCapacity, loadFactor);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.accessOrder </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> accessOrder;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="添加键值对" tabindex="-1">添加键值对 <a class="header-anchor" href="#添加键值对" aria-label="Permalink to &quot;添加键值对&quot;">​</a></h2><p><code>LinkedHashMap</code> 添加键值对使用从 <code>HashMap</code> 继承来的 <code>put(K key, V value)</code> 方法，在设置值时，如果对应位置没有结点，则会调用 <code>newNode(int hash, K key, V value, Node&lt;K,V&gt; e)</code> 方法去创建结点；由于 <code>LinkedHashMap</code> 使用了自定义的结点 <code>Entry&lt;K, V&gt;</code>，因此重写了 <code>newNode</code> 方法如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Node</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">newNode</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> hash, K key, V value, Node</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> e) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    LinkedHashMap.Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; p </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedHashMap.Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt;(hash, key, value, e);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将结点加入末尾</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">linkNodeLast</span><span style="color:#E1E4E8;">(p);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> p;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">linkNodeLast</span><span style="color:#E1E4E8;">(LinkedHashMap.Entry</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> p) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 记录原尾节点到 last 中</span></span>
<span class="line"><span style="color:#E1E4E8;">    LinkedHashMap.Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; last </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 设置 tail 指向 p，变更新的尾节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    tail </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果原尾节点 last 为空，说明 head 也为空，所以 head 也指向 p</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (last </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        head </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// last &lt;=&gt; p，相互指向</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        p.before </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> last;</span></span>
<span class="line"><span style="color:#E1E4E8;">        last.after </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Node</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">newNode</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> hash, K key, V value, Node</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> e) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建结点</span></span>
<span class="line"><span style="color:#24292E;">    LinkedHashMap.Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; p </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedHashMap.Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt;(hash, key, value, e);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将结点加入末尾</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">linkNodeLast</span><span style="color:#24292E;">(p);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> p;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">linkNodeLast</span><span style="color:#24292E;">(LinkedHashMap.Entry</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> p) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 记录原尾节点到 last 中</span></span>
<span class="line"><span style="color:#24292E;">    LinkedHashMap.Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; last </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 设置 tail 指向 p，变更新的尾节点</span></span>
<span class="line"><span style="color:#24292E;">    tail </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果原尾节点 last 为空，说明 head 也为空，所以 head 也指向 p</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (last </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        head </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// last &lt;=&gt; p，相互指向</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        p.before </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> last;</span></span>
<span class="line"><span style="color:#24292E;">        last.after </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="回调操作" tabindex="-1">回调操作 <a class="header-anchor" href="#回调操作" aria-label="Permalink to &quot;回调操作&quot;">​</a></h2><p>在 <code>HashMap</code> 内部，当访问、添加、删除结点后，会执行对应的回调操作方法 <code>afterNodeAccess(Node&lt;K,V&gt; e)</code>、<code>afterNodeInsertion(boolean evict)</code>、<code>afterNodeRemoval(Node&lt;K,V&gt; e)</code>，这三个方法的默认实现为空，<code>LinkedHashMap</code> 通过重写这三个方法，自定义扩展需要逻辑。</p><h3 id="访问回调" tabindex="-1">访问回调 <a class="header-anchor" href="#访问回调" aria-label="Permalink to &quot;访问回调&quot;">​</a></h3><p>访问回调方法 <code>afterNodeAccess(Node&lt;K,V&gt; e)</code> 中，必要要设置 <code>accessOrder</code> 为 true 才会执行后面的逻辑，即表示该 Map 通过访问顺序排序。其主要步骤为：</p><ol><li>访问一个结点后，将其从链表移出；</li><li>将该结点放入链表的末尾。</li></ol><p>这样做的目的是将最常访问的元素，放在链表的末尾（原理为 LRU 算法）</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">afterNodeAccess</span><span style="color:#E1E4E8;">(Node</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> e) { </span><span style="color:#6A737D;">// move node to last</span></span>
<span class="line"><span style="color:#E1E4E8;">    LinkedHashMap.Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; last;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 要求 accessOrder 为 true；last 缓存旧尾结点；要求 e 不是尾结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (accessOrder </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (last </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tail) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> e) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// p 执行当前结点 e</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// b 指向前一个结点 </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// a 指向后一个结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        LinkedHashMap.Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; p </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">            (LinkedHashMap.Entry</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">)e, b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p.before, a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p.after;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 移出 p</span></span>
<span class="line"><span style="color:#E1E4E8;">        p.after </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (b </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            head </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">            b.after </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (a </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            a.before </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">            last </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将 p 挂在链表尾部</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (last </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            head </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            p.before </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> last;</span></span>
<span class="line"><span style="color:#E1E4E8;">            last.after </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 尾结点指向 p</span></span>
<span class="line"><span style="color:#E1E4E8;">        tail </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">modCount;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">afterNodeAccess</span><span style="color:#24292E;">(Node</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> e) { </span><span style="color:#6A737D;">// move node to last</span></span>
<span class="line"><span style="color:#24292E;">    LinkedHashMap.Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; last;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 要求 accessOrder 为 true；last 缓存旧尾结点；要求 e 不是尾结点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (accessOrder </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (last </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tail) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> e) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// p 执行当前结点 e</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// b 指向前一个结点 </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// a 指向后一个结点</span></span>
<span class="line"><span style="color:#24292E;">        LinkedHashMap.Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; p </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">            (LinkedHashMap.Entry</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">)e, b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p.before, a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p.after;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 移出 p</span></span>
<span class="line"><span style="color:#24292E;">        p.after </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (b </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            head </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">            b.after </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (a </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            a.before </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> b;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">            last </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> b;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将 p 挂在链表尾部</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (last </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            head </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            p.before </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> last;</span></span>
<span class="line"><span style="color:#24292E;">            last.after </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 尾结点指向 p</span></span>
<span class="line"><span style="color:#24292E;">        tail </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">++</span><span style="color:#24292E;">modCount;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>另外，在 <code>HashMap</code> 的 <code>get</code> 和 <code>getOrDefault</code> 方法中，没有调用 <code>afterNodeAccess</code> 方法，<code>LinkedHashMap</code> 重写了这两个方法，在查询结点后，增加了根据 <code>accessOrder</code> 参数决定是否执行 <code>afterNodeAccess</code> 的判断。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(Object key) {</span></span>
<span class="line"><span style="color:#E1E4E8;">     Node&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; e;</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getNode</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">hash</span><span style="color:#E1E4E8;">(key), key)) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">         </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#6A737D;">// 增加的内容</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (accessOrder)</span></span>
<span class="line"><span style="color:#E1E4E8;">         </span><span style="color:#B392F0;">afterNodeAccess</span><span style="color:#E1E4E8;">(e);</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> e.value;</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> V </span><span style="color:#B392F0;">getOrDefault</span><span style="color:#E1E4E8;">(Object key, V defaultValue) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Node&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; e;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((e </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getNode</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">hash</span><span style="color:#E1E4E8;">(key), key)) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> defaultValue;</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#6A737D;">// 增加的内容</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (accessOrder)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">afterNodeAccess</span><span style="color:#E1E4E8;">(e);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> e.value;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> V </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(Object key) {</span></span>
<span class="line"><span style="color:#24292E;">     Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; e;</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getNode</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(key), key)) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">         </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6A737D;">// 增加的内容</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (accessOrder)</span></span>
<span class="line"><span style="color:#24292E;">         </span><span style="color:#6F42C1;">afterNodeAccess</span><span style="color:#24292E;">(e);</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> e.value;</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> V </span><span style="color:#6F42C1;">getOrDefault</span><span style="color:#24292E;">(Object key, V defaultValue) {</span></span>
<span class="line"><span style="color:#24292E;">    Node&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; e;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((e </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getNode</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(key), key)) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> defaultValue;</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6A737D;">// 增加的内容</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (accessOrder)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">afterNodeAccess</span><span style="color:#24292E;">(e);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> e.value;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="添加回调" tabindex="-1">添加回调 <a class="header-anchor" href="#添加回调" aria-label="Permalink to &quot;添加回调&quot;">​</a></h3><p>添加回调方法 <code>afterNodeInsertion(boolean evict)</code> 中，如果满足一下条件，会从链表中删除最老的结点（最不常访问）：</p><ol><li><code>evict</code> 参数为 true，在 HashMap 中调用 <code>afterNodeInsertion</code> 时传参都是 true；</li><li>链表不为空；</li><li><code>removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code> 的结果为 true，默认实现返回 false，这意味着想要使用 LRU 缓存必须重写该方法，使得一定情况下返回 true。</li></ol><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// evict 参数表示是否需要移除数据</span></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">afterNodeInsertion</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> evict) { </span><span style="color:#6A737D;">// possibly remove eldest</span></span>
<span class="line"><span style="color:#E1E4E8;">    LinkedHashMap.Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; first;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 满足条件时删除最老的结点（最不常访问）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (evict </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (first </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> head) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">removeEldestEntry</span><span style="color:#E1E4E8;">(first)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        K key </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> first.key;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 删除头结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">removeNode</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">hash</span><span style="color:#E1E4E8;">(key), key, </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// LinkedHashMap 默认不移除最老的数据</span></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">removeEldestEntry</span><span style="color:#E1E4E8;">(Map.Entry</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> eldest) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// evict 参数表示是否需要移除数据</span></span>
<span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">afterNodeInsertion</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> evict) { </span><span style="color:#6A737D;">// possibly remove eldest</span></span>
<span class="line"><span style="color:#24292E;">    LinkedHashMap.Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; first;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 满足条件时删除最老的结点（最不常访问）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (evict </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (first </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> head) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">removeEldestEntry</span><span style="color:#24292E;">(first)) {</span></span>
<span class="line"><span style="color:#24292E;">        K key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> first.key;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 删除头结点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">removeNode</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(key), key, </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// LinkedHashMap 默认不移除最老的数据</span></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">removeEldestEntry</span><span style="color:#24292E;">(Map.Entry</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> eldest) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="删除回调" tabindex="-1">删除回调 <a class="header-anchor" href="#删除回调" aria-label="Permalink to &quot;删除回调&quot;">​</a></h3><p>删除回调方法 <code>afterNodeRemoval(Node&lt;K,V&gt; e)</code>，用于在 HashMap 删除键值对后，从链表中删除对应的结点</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">afterNodeRemoval</span><span style="color:#E1E4E8;">(Node</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> e) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    LinkedHashMap.Entry&lt;</span><span style="color:#F97583;">K</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">V</span><span style="color:#E1E4E8;">&gt; p </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">        (LinkedHashMap.Entry</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">K,V</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">)e, b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p.before, a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p.after;</span></span>
<span class="line"><span style="color:#E1E4E8;">    p.before </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> p.after </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (b </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        head </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">        b.after </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (a </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        tail </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">        a.before </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">afterNodeRemoval</span><span style="color:#24292E;">(Node</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> e) {</span></span>
<span class="line"><span style="color:#24292E;">    LinkedHashMap.Entry&lt;</span><span style="color:#D73A49;">K</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">V</span><span style="color:#24292E;">&gt; p </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">        (LinkedHashMap.Entry</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">K,V</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">)e, b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p.before, a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p.after;</span></span>
<span class="line"><span style="color:#24292E;">    p.before </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> p.after </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (b </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        head </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">        b.after </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (a </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        tail </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> b;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">        a.before </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> b;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><code>LinkedHashMap</code> 在 <code>HashMap</code> 的基础上，在内部增加了一个双向链表，用于保存插入元素的顺序，解决了 <code>HashMap</code> 不能随时保持遍历顺序和插入顺序一致的问题；同时通过 <code>accessOrder</code> 参数和回调函数，支持通过访问顺序排序。</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://www.iocoder.cn/" target="_blank" rel="noreferrer">芋道源码</a></li><li><a href="https://blog.csdn.net/hequnwang10/article/details/124732318" target="_blank" rel="noreferrer">LinkedHashMap 源码解析</a></li></ul>`,41),o=[e];function c(r,t,E,y,i,d){return a(),n("div",null,o)}const F=s(p,[["render",c]]);export{u as __pageData,F as default};
