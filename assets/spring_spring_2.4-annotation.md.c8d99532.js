import{_ as e,o,c as t,Q as a}from"./chunks/framework.bf9fbf22.js";const k=JSON.parse('{"title":"Spring 核心注解","description":"","frontmatter":{"title":"Spring 核心注解","index":false,"article":true,"date":"2022-10-12T00:00:00.000Z"},"headers":[],"relativePath":"spring/spring/2.4-annotation.md","filePath":"spring/spring/2.4-annotation.md"}'),n={name:"spring/spring/2.4-annotation.md"},l=a('<h2 id="bean-配置注解" tabindex="-1">Bean 配置注解 <a class="header-anchor" href="#bean-配置注解" aria-label="Permalink to &quot;Bean 配置注解&quot;">​</a></h2><ol><li>@ComponentScan</li></ol><blockquote><p>@ComponentScan 注解用于配置 Spring 需要扫描的被组件注解注释的类所在的包。</p><p>可以通过配置其 basePackages 属性或者 value 属性来配置需要扫描的包路径。value 属性是 basePackages 的别名。</p></blockquote><ol start="2"><li>@Bean</li></ol><blockquote><p>@Bean 注解主要的作用是告知 Spring，被此注解所标注的类将需要纳入到 Bean 管理工厂中。</p><p><code>initMethod</code> 和 <code>destroyMethod</code> 属性用来配置初始化和销毁的回调方法。</p></blockquote><ol start="3"><li>@Scope</li></ol><blockquote><p>@Scope 注解可以用来定义 @Component 标注的类的作用范围以及 @Bean 所标记的类的作用范围。</p><p>@Scope 所限定的作用范围有：singleton、prototype、request、session、globalSession 或者其他的自定义范围。</p></blockquote><ol start="4"><li>@Autowired</li></ol><blockquote><p><code>@Autowired</code> 注解用于标记 Spring 将要解析和注入的依赖项。此注解可以作用在构造函数、字段和 setter 方法上。</p></blockquote><ol start="5"><li>@Primary</li></ol><blockquote><p>当系统中需要配置多个具有相同类型的 Bean 时，<code>@Primary</code> 可以定义这些 Bean 的优先级。</p></blockquote><ol start="6"><li>@Qualifier</li></ol><blockquote><p>当系统中存在同一类型的多个 Bean 时，<code>@Autowired</code> 在进行依赖注入的时候就不知道该选择哪一个实现类进行注入。此时，我们可以使用@Qualifier 注解来指定实现类。</p></blockquote><ol start="7"><li>@Resource</li></ol><blockquote><p>Spring 还通过在字段或 bean 属性 setter 方法上使用 JSR-250 @Resource(javax.annotation.Resource) 注解来支持注入。</p><p>@Resource 在没有明确指定 name 时，其行为类似于 @Autowired。</p></blockquote><ol start="8"><li>@value</li></ol><blockquote><p>@Value 通常用于注入外部属性。</p></blockquote>',17),i=[l];function r(c,p,s,u,d,_){return o(),t("div",null,i)}const q=e(n,[["render",r]]);export{k as __pageData,q as default};
