import{_ as o,W as c,X as l,Z as a,$ as n,a0 as s,a1 as i,C as e}from"./framework-ea95e8eb.js";const d={},r=a("h2",{id:"题目链接",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#题目链接","aria-hidden":"true"},"#"),n(" 题目链接")],-1),u={href:"https://leetcode.cn/problems/intersection-of-two-linked-lists",target:"_blank",rel:"noopener noreferrer"},k={id:"题目描述",tabindex:"-1"},h=a("a",{class:"header-anchor",href:"#题目描述","aria-hidden":"true"},"#",-1),m=i(`<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code>，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code>。</p><p>图示两个链表在节点 <code>c1</code> 开始相交：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="pic" loading="lazy"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" alt="示例 " loading="lazy"></p><div class="language-text" data-ext="text"><pre class="language-text"><code>输出：2
</code></pre></div><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路" aria-hidden="true">#</a> 解题思路</h2><p>方法一：遍历其中一个链表，用 HashMap 存储链表节点，再遍历另一个判断是否含有该结点，这里主要介绍方法二；</p><p>方法二：<strong>双指针</strong></p><p>如果两个链表相交，那么相交点之后的长度是相同的；我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。为此，我们必须消除两个链表的长度差：</p><ul><li>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</li><li>如果 pA 到了末尾，则 pA = headB 继续遍历</li><li>如果 pB 到了末尾，则 pB = headA 继续遍历</li><li>比较长的链表指针指向较短链表 head 时，长度差就消除了</li><li>如此，只需要将最短链表遍历两次即可找到位置</li></ul><p>如图所示：</p><p><img src="https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-相交链表.png" alt="" loading="lazy"></p><h2 id="示例代码" tabindex="-1"><a class="header-anchor" href="#示例代码" aria-hidden="true">#</a> 示例代码</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">getIntersectionNode</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> headA<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>headA <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> headB <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
         <span class="token class-name">ListNode</span> a <span class="token operator">=</span> headA<span class="token punctuation">;</span>
         <span class="token class-name">ListNode</span> b <span class="token operator">=</span> headB<span class="token punctuation">;</span>
         <span class="token comment">// 互换之后，a 和 b 距离各自末尾的距离一样，如果不想交，最后都会等于 null，退出循环</span>
         <span class="token keyword">while</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
             a <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> headB <span class="token operator">:</span> a<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
             b <span class="token operator">=</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> headA <span class="token operator">:</span> b<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         <span class="token keyword">return</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="复杂度分析" tabindex="-1"><a class="header-anchor" href="#复杂度分析" aria-hidden="true">#</a> 复杂度分析</h2><ul><li>空间复杂度 O(1)</li><li>时间复杂度为 O(n)</li></ul>`,19);function v(b,_){const t=e("ExternalLinkIcon"),p=e("Badge");return c(),l("div",null,[r,a("ul",null,[a("li",null,[a("a",u,[n("160. 相交链表"),s(t)])])]),a("h2",k,[h,n(" 题目描述 "),s(p,{text:"简单",type:"tip"})]),m])}const x=o(d,[["render",v],["__file","160-相交链表.html.vue"]]);export{x as default};
